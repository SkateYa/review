***
[TOC]
***
###  输出日期格式为：yyyy-mm-dd
```javascript
 function getCurrentDateFormatted() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, "0"); // 月份是从0开始的，所以需要加1
        const day = String(now.getDate()).padStart(2, "0"); // 日期不足两位时前面补0
        return `${year}-${month}-${day}`;
      }

      const formattedDate = getCurrentDateFormatted();
      console.log(formattedDate); // 输出格式为：yyyy-mm-dd
```
### 计算数组中每个元素出现的次数
```javascript
var names = ['red', 'red', 'blue', 'blue', 'yellow'];
var nameNum = names.reduce((pre,cur)=>{
   //  if(pre[cur]){
    if(cur in pre){
        pre[cur]++
    }else{
        pre[cur] = 1 
    }
    return pre
},{})
console.log(nameNum); // {red: 2, blue: 2, yellow: 1}
```
### instanceof 操作符的实现原理及实现

instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。

```javascript
function myInstanceof(left, right) {
  // 获取对象的原型
  // let proto = left.__proto__;
  let proto = Object.getPrototypeOf(left);
  // 获取构造函数的 prototype 对象
  let prototype = right.prototype;

  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;
    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型
    // proto = proto.__proto__;
    proto = Object.getPrototypeOf(proto);
  }
}
```
### 手写 new 操作符

```javascript
//   新建了一个object对象
//   修改构造函数this的指向，使其指向新建的object对象，并且执行构造函数
//   为object对象添加一个proto属性，使其指向构造函数的prototype属性
//   将这个object对象返回出去
function Fun(age, name) {
  this.age = age;
  this.name = name;
  return 11;
}
function myNew(fn, ...args) {
  // args是数组
  //1.创建了一个空的对象
  const obj = {}; //var obj = Object.create({})
  //2.将空对象的原型，指向于构造函数的原型
  // 等价于  Object.setPrototypeOf(obj, fn.prototype);
  obj.__proto__ = fn.prototype;
  //3.将空对象作为构造函数的上下文(改变this指向)
  const result = fn.apply(obj, args);
  //4.对构造函数有返回值的处理判断,如果返回的是基本类型不影响结果，如果是引用类型，修改结果
  return result instanceof Object ? result : obj;
}

console.log(new Fun(18, "张三")); // Fun {age: 18, name: '张三'}
console.log(myNew(Fun, 18, "张三")); // Fun {age: 18, name: '张三'}
var obj1 = new Fun(18, "张三");
var obj2 = myNew(Fun, 18, "张三");
console.log(obj2.__proto__ === Fun.prototype); // true
console.log(obj1.__proto__ === Fun.prototype); // true
```
### function (1,2)可以改成function (1)(2)
```
// 原始函数，接受两个参数  
function add(a, b) {  
  return a + b;  
}  
  
// 柯里化版本的函数  
function curryAdd(a) {  
  return function(b) {  
    return a + b;  
  };  
}  
  
// 使用柯里化版本的函数  
const addFive = curryAdd(2); // 返回一个新的函数，该函数等待第二个参数  
const result = addFive(3); // 调用返回的函数并传入第二个参数，得到结果 8  
const addResult = add(2,3) // 5
const res = curryAdd(2)(3)  // 5
console.log(result); // 输出：5
```
### 实现一个有并发限制的promise调度器
应用场景： 
实现大文件上传，分片可以分成100片，200片，前端不对请求并行数进行限制，
谷歌浏览器，一次最大的tcp连接（同域下6），可能造成大文件并发上传，6个tcp连接数都被占满，造成浏览器卡顿和性能卡死的情况，
可以限制promise的请求数，并发数，限制为6个

要创建一个具有并发限制的Promise调度器，你需要维护一个队列来保存待处理的Promise，

以及一个计数器来跟踪当前正在运行的Promise数量。当Promise完成时，你需要更新计数器，

并从队列中取出下一个Promise来执行，直到达到并发限制或队列为空。

```javascript
const arr = [];
for (let i = 0; i < 10; i++) {
  arr.push(
    () =>
      new Promise((resolve) => {
        setTimeout(() => {
          console.log("done", i);
          resolve();
        }, 100 * i);
      })
  );
}

const parallelRun = () => {
  const runingTask = new Map();
  const inqueue = (totalTask, max) => {
    // 正在运行的任务个数 < 最大个数 
    while (runingTask.size < max && totalTask.length) {
      // 删除第一个元素
      const newTask = totalTask.shift();
      // 
      const tempName = totalTask.length;
      runingTask.set(tempName, newTask);
      newTask().finally(() => {
        runingTask.delete(tempName);
        inqueue(totalTask, max);
      });
    }
  };
  return inqueue;
};

parallelRun()(arr, 6);
```

### 防抖
其实，我开发一般用 lodash库，利用里面的debounce(防抖）和throttle(节流）来做的
**防抖函数的应用场景：**

- 表单验证
- 搜索框搜索输入
- 文本编辑器实时保存

**节流函数的****适⽤场景：** 

- 拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动 
- 缩放场景：监控浏览器resize 
- 滚动scroll事件
- 鼠标滑动
- 下拉加载

```javascript
// 防抖 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时，重新出发定时器。
/* 
   应用场景
      登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖
      调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖
       文本编辑器实时保存，当无任何更改操作一秒后进行保存
  */
function debounce(fun, delay) {
  let timer;
  return function () {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fun.apply(this, arguments);
    }, delay);
  };
}
```

### 节流

```javascript
// 节流  规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效
 /* 
     应用场景
        鼠标连续不断地触发某事件（如点击），单位时间内只触发一次；
        监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断。例如：懒加载；
        浏览器播放事件，每个一秒计算一次进度信息等
   */
function throttle(fun, delay) {
  let timer;
  return function () {
    if (!timer) {
      timer = setTimeout(() => {
        fun.apply(this, arguments);
        timer = null;
      }, delay);
    }
  };
}

 function throttle(func, delay) {
    // 上一次执行的时间
    let pre = 0;
    return function () {
      // 现在的时间
      let now = new Date();
      //   如果现在的时间减去上次执行的时间大于delay就执行函数
      if (now - pre > delay) {
        func.apply(this, arguments);
        // 把当前时间赋值给上一次的执行时间
        pre = now;
      }
    };
  }
```

### a==1&&a==2&&a==3&&a==4.html

```javascript
// 第一种方法
var a = {
  value: 0,
  valueOf: function () {
    this.value++;
    return this.value;
  },
};

// 第二种方法
const a = {
  value: [3, 2, 1],
  valueOf: function () {
    return this.value.pop();
  },
};

// 第三种方法
var a = {
  i: 1,
  toString() {
    return this.i++;
  },
};

// 第四种方法
var a = [1, 2, 3];
a.join = a.shift;

// 第五种方法
Object.defineProperty(window, "a", {
  get: function () {
    if (this.value) {
      return (this.value += 1);
    } else {
      return (this.value = 1);
    }
  },
});

console.log(a == 1 && a == 2 && a == 3); //true
```

### 数组去重

```javascript
 // 1. from && set
    let arr = [1, 1, 4, 50, 50, 6, 2, 2];
    let res = Array.from(new Set(arr));
    console.log(res);

// 2. filter && indexOf
    let arr = [2, 2, 33, 44, 33];
    let res = arr.filter((item, index, arr) => {
    return arr.indexOf(item) == index;
    });
    console.log(res);

// 3. forEach && includes
    let arr = [2, 2, 33, 44, 33];
    let res = [];
    arr.forEach((item) => {
    if (!res.includes(item)) {
        res.push(item);
    }
    });
    console.log(res);

// 4. filter &&  Map
    let arr = [2, 2, 33, 44, 33];
    const tem = new Map();
    let res = arr.filter((item) => !tem.has(item) && tem.set(item, 1));
    console.log(res);
```

###  斐波那契数列(百度笔试题)
数列中某一项的值，等于它的前一项加上前前一项的和。
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……
```javascript
function fibonacci(n){
    if(n === 1 || n === 0 ) return n;
    return fibonacci(n-1) + fibonacci(n-2);
}

```

```
function fib(n) {
    let a = 0, b = 1;
    for (let i = 0; i < n; i++) {
        let temp = a;
        a = b;
        b = temp + b;
    }
    return a;
}
```

### 继承
#### 1. class继承

```javascript
// 1. class+extends继承
class Parent{
  constructor(){
      this.age = 18
  }
}

class Child extends Parent{
  constructor(){
    // 必须要写，否则报错，super作为函数调用时表示父类的构造函数，
    // 但super内部的this指向的是子类
      super()
      this.name = '张三'
  }
}
let o1 = new Child(22)
console.log(o1) // child {name:'张三',age:18}
```
#### 2. 原型链继承

```javascript
  /* 　重点：让子实例的原型等于父类的实例。
　　　　优点：1. 实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）
　　　　缺点：1. 新实例无法向父类构造函数传参。
　　　　　　　2. 继承单一。
　　　　　　　3. 所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！） */
  function Parent() {
    this.age = 20;
    this.hobbyList = ["唱歌", "跳舞"];
  }

  function Child() {
    this.name = "张三";
  }

  //继承父类
  Child.prototype = new Parent();
  let c1 = new Child();
  let c2 = new Child();
  // 所有新实例都会共享父类实例的属性  如果属性是引用数据类型，修改了一个实例的属性，其他实例的属性都发生变化，如果属性是基本数据类型的话，就不会有这个变化
  c1.name = "李四";
  c1.hobbyList.push("打游戏");
  console.log(c1, c1.hobbyList); // Child {name: '李四'} (3) ['唱歌', '跳舞', '打游戏']
  console.log(c2, c2.hobbyList); //  Child {name: '张三'} (3) ['唱歌', '跳舞', '打游戏'] */
```
#### 3. 构造函数继承
```javascript
  /*   重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））
　　　　优点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
　　　　　　　2、解决了原型链继承缺点1、2、3。
　　　　　　　3、可以继承多个构造函数属性（call多个）。
　　　　　　　4、在子实例中可向父实例传参。
            5、解决了原型链实现继承的不能传参的问题和父类的原型共享的问题。 
　　　　缺点：1、只能继承父类构造函数的属性。
　　　　　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）
　　　　　　　3、每个新实例都有父类构造函数的副本，臃肿。
            4、子类无法访问父类原型中的方法和属性。（这个原型链继承可以解决) */
  function Parent() {
    this.age = 22;
    this.hobbyList = ['唱歌']
  }
  Parent.prototype.sex = "男";

  function Child() {
    this.name = "张三";
    // 创建子类实例时调用Parent构造函数，于是Child的每个实例都会将Parent中的属性复制一份
    // this指向Child
    Parent.call(this);
  }
  //  无法继承父类原型的属性。
  let o1 = new Child(); 
  let o2 = new Child();

  console.log(o1);  // child {age: 22, name: "张三"} hobbyList: ['唱歌']
  console.log(o2);  // child {age: 22, name: "张三"} hobbyList: ['唱歌']
```
#### 4. 组合继承（原型链+构造函数）

```javascript
  /*  重点：结合了两种模式的优点,使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。传参和复用
　　　　优点：1、可以继承父类原型上的属性，可以传参，可复用。
　　　　　　　2、每个新实例引入的构造函数属性是私有的。
　　　　缺点：调用了两次父类构造函数, 生成了两份实例（耗内存），子类的构造函数会代替原型上的那个父类构造函数。
     */
  function Parent() {
    this.age = 11;
  }

  Parent.prototype.sex = "男";

  function Child() {
    // 借用构造函数模式
    Parent.call(this);
    this.name = "张三";
  }

  // 原型链继承
  Child.prototype = new Parent();
  Child.prototype.constructor = Child;
  let c1 = new Child();
  console.log(c1);   // age: 11 name: "张三"
```
#### 5. 原型式继承

```javascript
  /*  
      重点： 用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。
            object.create()就是这个原理。
      特点： 类似于复制一个对象，用函数来包装。
      缺点： 1、所有实例都会继承原型上的属性。 
            2、无法实现复用。（新实例属性都是后面添加的） 
      */

// es5之后
var parent = {
  name: "Parent",
  sayHello: function () {
    console.log("Hello");
  },
};

var child = Object.create(parent);
console.log(child.name); // Parent
child.sayHello(); // Hello

 /* 
// 第二种  es5之前
var Parent = {
  name: "Parent",
  sayHello: function () {
    console.log("Hello");
  },
};

// 利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。
function Child(obj) {
  function F() {}
  F.prototype = obj; // 继承了传入的参数
  return new F(); // 返回函数对象
}

var child = Child(Parent);
console.log(child.name); // Parent
child.sayHello(); // Hello 
*/

```
#### 6. 寄生式继承

```javascript
 /*    
  重点：就是给原型式继承外面套了个壳子。
  优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。
  缺点：没用到原型，无法复用。
    */

function createChild(parent) {
  const child = Object.create(parent);
  child.name = "Child";
  child.sayHello = function () {
    console.log(`Hello, I'm ${this.name}`);
  };
  return child;
}

const parent = {
  name: "Parent",
};

const child = createChild(parent);
child.sayHello(); // 输出 "Hello, I'm Child"



  // // 第二种方式
// function Parent() {
//   this.age = 100;
// }

// function child(obj) {
//   function F() {}
//   F.prototype = obj; //继承了传入的参数
//   return new F(); //返回函数对象
// }
// var sup = new Parent();
// //以上是原型式继承，给原型式继承再套个壳子传递参数
// function subObject(obj) {
//   var sub = child(obj);
//   sub.name = "gar";
//   return sub;
// }
// var sup2 = subObject(sup);
// //这个函数经过声明之后就成了可增添属性的对象
// console.log(typeof subObject); //function
// console.log(typeof sup2); //object
// console.log(sup2.name); //"gar"，返回了个sub对象，继承了sub的属性
```
#### 7. 寄生组合继承（最优）

```javascript
 function Parent() {
    this.age = 100;
  }

  function Child() {
    // 借用构造函数模式
    Parent.call(this);
    this.name = "张三";
  }
  // 原型链继承
  Child.prototype = Object.create(Parent.prototype);
  Child.prototype.constructor = Child;
  let o4 = new Child();
  console.log(o4, o4.name, o4.age); // Child {age: 100, name: '张三'} '张三' 100


 //2.第二种方法
/*  function Parent() {
    this.age = 100;
  }

  function child(obj) {
    function F() {}
    F.prototype = obj;
    return new F();
  }
  //child就是F实例的另一种表示法
  var con = child(Parent.prototype);
  //con实例(F实例)的原型继承了父类函数的原型//上述更像是原型链继承，只不过只继承了原型属性
  //组合
  function Sub() {
    Parent.call(this); //这个继承了父类构造函数的属性
  } //解决了组合式俩次调用构造函数属性的缺点//重点
  Sub.prototype = con; //继承了con实例
  con.constructor = Sub; //一定要修复实例
  var sub1 = new Sub(); //Sub的实例就继承了构造函数属性，父类实例，con的函数属性
  console.log(sub1, sub1.age); //10; */

```

### 金额格式化

```javascript
// 金额格式化展示，展示出诸如“12,345,678.90“格式的字符串
 // toLocaleString()  可以用来格式化，比如数字的格式化， 如下 整数部分每三位加一个逗号
// charAt 获取指定索引的值
// toFixed  保留2位小数
function toThousands(amount) {
  let newNumber = amount.toFixed(2);
  let [num, decimalPart] = newNumber.split(".");
  let result = "";
  let counter = 0
  for (let i = num.length - 1; i >= 0; i--) {
    counter++;
    result = num.charAt(i) + result;
    if (counter % 3 === 0 && i !== 0) {
      result = "," + result;
    }
  }
  return result + "." + (decimalPart ? decimalPart : "00");
}

console.log(toThousands(12345678));
console.log(toThousands(123.1)); // 123.10
console.log(toThousands(1234)); // 1,234.00
console.log(toThousands(1234.56)); // 1,234.56
console.log(toThousands(0)); // 0.00

```

### 实现一个大数加法函数

```javascript
 // 请实现一个大数加法函数，不使用BigInt，用以处理极大数字之间的加法运算。数据约定：两个数字均为正整数。
function bigNumberAdd(num1, num2) {
  // 下标
  let i = num1.length - 1;
  let j = num2.length - 1;
  let carry = 0; // 余数
  let result = "";

  while (i >= 0 || j >= 0 || carry > 0) {
    let sum = carry;
    if (i >= 0) {
      sum += parseInt(num1[i--]);
    }
    if (j >= 0) {
      sum += parseInt(num2[j--]);
    }
    result = (sum % 10) + result; // 结果
    carry = Math.floor(sum / 10); // 余数
  }

  return result;
}

// 测试
let num1 = "999999999927362553333323233222133332233342323";
let num2 = "89";
console.log(bigNumberAdd(num1, num2)); // 999999999927362553333323233222133332233342335
console.log((BigInt(num1) + BigInt(num2)).toString());
```

### 算法-修复路径

```javascript
 分类：栈与递归
    题目描述
    给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。

    在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。

    请注意，返回的 规范路径 必须遵循下述格式：

    始终以斜杠 '/' 开头。
    两个目录名之间必须只有一个斜杠 '/' 。
    最后一个目录名（如果存在）不能 以 '/' 结尾。
    此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
    返回简化后得到的 规范路径 。

    提示：

    1 <= path.length <= 3000
    path 由英文字母，数字，'.'，'/' 或 '_' 组成。
    path 是一个有效的 Unix 风格绝对路径。


    示例 1：
    输入：path = "/home/"
    输出："/home"
    解释：注意，最后一个目录名后面没有斜杠。

    示例 2：
    输入：path = "/../"
    输出："/"
    解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。
    
    示例 3：
    输入：path = "/home//foo/"
    输出："/home/foo"
    解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
    思路：
    使用 string.split() 方法, 以斜杠 (/) 为分隔符, 将 Unix 路径 path 拆分为若干字符串组成的数组.

    将字符串顺序压入栈中

    不包含元素, 一个点 (.) 时, 跳过.

    两个点 (..) 时, 将当前栈顶元素移出栈.
    */

// 接受一个路径字符串作为参数
var simplifyPath = function (path) {
  const array = path.split("/");
  // 定义一个空数组stack，用来模拟一个栈的结构
  const stack = [];
  // 代码遍历数组array中的每个字符串。如果字符串为空或者为"."，则跳过
  // 如果字符串为".."，则将stack中的最后一个元素弹出
  // 否则，将字符串推入stack中
  for (let str of array) {
    if (str === "" || str === ".") {
      continue;
    } else if (str === "..") {
      stack.pop();
    } else {
      stack.push(str);
    }
  }
  // 在遍历完整个数组后，如果stack为空，则返回根路径"/"
  if (stack.length === 0) {
    return "/";
  }
  let result = "";
  // 将stack中的元素按照"/"连接起来，形成最终路径字符串result，然后返回该字符串。
  for (let str of stack) {
    result += `/${str}`;
  }
  return result;
};
console.log(simplifyPath("/home/")); //  /home
console.log(simplifyPath("/../")); // /
console.log(simplifyPath("/home//foo/")); // /home/foo
```
## 排序
<10 插入排序，>10 快排 



｜  排序法  |   最差时间分析   |   平均时间复杂度 | 稳定度 |     空间复杂度  |
|  冒泡排序 |    O(n2)   |    O(n2)      |  稳定  |      O(1)     |
|  选择排序 |    O(n2)   |    O(n2)       | 不稳定  |      O(1)     |
|  插入排序 |    O(n2)   |    O(n2)       |  稳定  |      O(1)      |
|  快速排序 |    O(n2)   | O(n*logn)      | 不稳定  | O(log2n)~O(n) |
|  归并排序 |O(n*logn)   | O(n*logn)      | 不稳定  | O(log2n)~O(n) |
|  希尔排序 |      O     |      O         | 不稳定  |      O(1)     |

|  堆排序   | O(n*logn) | O(n*logn)     | 不稳定  |      O(1)     |
| 二叉树排序|    O(n2)   | O(n*logn)     | 不一顶  |      O(n)     |

1.1 复杂度辅助记忆
冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n²)）（一遍找元素O(n)，一遍找位置O(n)）
快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)（一遍找元素O(n)，一遍找位置O(logn)）

1.2 稳定性辅助记忆
稳定性记忆-“快希选堆”（快牺牲稳定性） 
排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。


### 冒泡排序
![image](https://img-blog.csdnimg.cn/465e6006be434ad890efeab48d153ce1.gif#pic_center)

```javascript
 /*   
冒泡排序: 
  比较所有相邻元素,如果第一个比第二个大，则交换它们
  一轮下来保证可以找到一个数是最大的,执行n-1轮，就可以完成排序
  外层循环控制跑几轮, 内层循环负责每轮交换的次数
  */
const arr = [5, 2, 1, 3, 6, 8, 4, 5, 7, 0, 15];
// 因为是前后两两排序，所以只需要数组长度-1 次遍历即可
for (let i = 0; i < arr.length - 1; i++) {
  //  -i 是因为最后的位置是会动态改变的，当完成一次后,最后一位会变成倒数第二位
  for (let j = 0; j < arr.length - 1 - i; j++) {
    if (arr[j] > arr[j + 1]) {
      [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
    }
  }
}
console.log(arr, "----------------------冒泡排序");
// [0, 1, 2, 3, 4, 5, 5, 6, 7, 8, 15] '----------------------冒泡排序'
```

### 选择排序
![image]( https://img-blog.csdnimg.cn/0768fddbe21c4e96930181050f203963.gif#pic_center)
```javascript
 // 选择排序
  // 定义：选择排序是一种简单的排序算法，每次从未排序部分找到最小（或最大）的元素，然后放到已排序部分的末尾。
  // 重复（元素个数-1）次
  // 把第一个没有排序过的元素设置为最小值遍历每个没有排序过的元素
  // 如果元素＜ 现在的最小值
  // 将此元素设置成为新的最小值
  // 将最小值和第一个没有排序过的位置交换
  const arr = [5, 2, 1, 3, 6, 8, 4, 5, 7, 0, 15];
  for (let i = 0; i < arr.length - 1; i++) {
    let minIndex = i; //用于存储最小值的下标，排序刚开始时，假设最小值的下标就是选中的基准数据下标
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        // 如果找到更小的数，记录它的索引
        minIndex = j;
      }
    }
    // 将最小元素与当前索引的元素进行交换
    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
  }
  console.log(arr, "----------------------选择排序");
  // [0, 1, 2, 3, 4, 5, 5, 6, 7, 8, 15] '----------------------选择排序'
```
### 插入排序
![image](https://img-blog.csdnimg.cn/eff8219ab2ee4f30a093bca9b68633d3.gif#pic_center )
```javascript
// 插入排序 1
// 它的思想是将数组分为已排序和未排序两部分，初始时已排序部分只有一个元素，然后逐步将未排序部分中的元素
// 插入到已排序部分的正确位置上。通过重复这个过程，最终使得整个数组有序
const arr = [5, 2, 1, 3, 6, 8, 4, 5, 7, 0, 15];
function pickFun(params) {
  let preIndex = 0; // 进行大小对比的基准数据的下标
  let current = 0; // 进行大小对比的当前选中的剩余数量值
  for (let i = 1; i < params.length; i++) {
    preIndex = i - 1; // 进行基准数据赋值
    current = params[i]; // 获取当前进行对比的剩余数量值
    while (preIndex >= 0 && params[preIndex] > current) {
      params[preIndex + 1] = params[preIndex];
      preIndex--;
    }
    params[preIndex + 1] = current;
  }
  return params;
}
const pickAns = pickFun(arr);
console.log(pickAns, "----------------------插入排序");
// [0, 1, 2, 3, 4, 5, 5, 6, 7, 8, 15] '----------------------插入排序'


// 插入排序 2
function insertionSort(arr) {
  const len = arr.length;
  for (let i = 1; i < len; i++) {
    let current = arr[i]; // 当前要插入的元素
    let j = i - 1; // 已排序部分的最后一个元素的索引（当前元素的上一个）
    // 如果上一个元素比当前元素大，就将上一个元素放到当前元素的位置（即后移）
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j];
      j--; // 继续往前比
    }
    // 将当前元素插入（赋值）到正确的位置（因为j--了，所以j + 1是正确位置）
    arr[j + 1] = current;
  }
  return arr;
}
console.log(insertionSort(arr)); // [0, 1, 2, 3, 4, 5, 5, 6, 7, 8, 15]
```

### 快速排序
![image](https://img-blog.csdnimg.cn/1422bc9767454b08b6225dac636ab33a.gif#pic_center )
```javascript
  // 快速排序
  // 快速排序是一种高效的排序算法，采用分治的策略。它选择一个基准元素，将数组分成两个子数组，
  // 使得左边的元素都小于基准，右边的元素都大于基准，然后递归地对子数组进行排序。

  const arr = [5, 2, 1, 3, 6, 8, 4, 5, 7, 0, 15];
  function quickFun(arr) {
    //当进行递归的数组的长度小于等于 1 的时候直接返回该数组
    if (arr.length <= 1) {
      return arr;
    }
    const pivot = arr[0] // 选择第一个元素作为基准
    let leftArr = [];
    let rightArr = [];
    for (let i = 0; i < arr.length; i++) {
      // 小的放左边，大的放右边
      if (arr[i] > middleItem) {
        rightArr.push(arr[i]);
      } else {
        leftArr.push(arr[i]);
      }
    }

    return [...quickFun(leftArr), pivot, ...quickFun(rightArr)];// 递归地对左右两部分进行快速排序，并将结果拼接起来
  }
  const quickAns = quickFun(arr);
  console.log(quickAns, "----------------------快速排序");
  // [0, 1, 2, 3, 4, 5, 5, 6, 7, 8, 15] '----------------------快速排序'
```
### 归并排序
![image](https://img-blog.csdnimg.cn/be3ea526b9504d6eba2b036a91430e9a.gif#pic_center )
```javascript
// 归并排序是一种高效的排序算法，采用分治的策略。它将待排序的数组递归地划分为较小的子数组，然后将这些子数组逐一合并，直到整个数组排序完成。
const arr = [5, 2, 1, 3, 6, 8, 4, 5, 7, 0, 15];

//   归并排序 1
const mergeInto = (left, right) => {
  let result = [];
  while (left.length > 0 && right.length > 0) {
    if (left[0] <= right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
  }
  while (left.length) result.push(left.shift());
  while (right.length) result.push(right.shift());
  return result;
};

const sort = (arr) => {
  let len = arr.length;
  if (len < 2) {
    return arr;
  }
  const middle = Math.floor(len / 2),
    left = arr.slice(0, middle),
    right = arr.slice(middle);
  return mergeInto(sort(left), sort(right));
};

console.log(sort(arr));

//   归并排序 2
function mergeSort(arr) {
  // 基线条件：当数组长度小于等于 1 时，直接返回该数组
  if (arr.length <= 1) {
    return arr;
  }
  const mid = Math.floor(arr.length / 2); // 计算数组的中间位置
  const left = arr.slice(0, mid); // 将数组分为左右两部分
  const right = arr.slice(mid);

  // 递归地对左右两部分进行归并排序，并将结果合并
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  const result = [];
  let i = 0;
  let j = 0;
  // 比较左右两个子数组的元素，并按顺序加入结果数组
  while (i < left.length && j < right.length) {
    if (left[i] <= right[j]) {
      result.push(left[i]);
      i++;
    } else {
      result.push(right[j]);
      j++;
    }
  }
  // 处理剩余元素（如果有）
  while (i < left.length) {
    result.push(left[i]);
    i++;
  }
  while (j < right.length) {
    result.push(right[j]);
    j++;
  }

  return result;
}
const nums = [4, 5, 2, 7, 8];
console.log(mergeSort(arr)); // [2, 4, 5, 7, 8]
```

### 希尔排序
![image]( )
```javascript
// 希尔排序
// 基于插入排序进行的优化，先将整个数组按照数组长度的一半进行分组使用插入排序，
// 完成后，再将整个数组按照数组长度的1/4进行分组使用插入排序，重复以上步骤，直到分组长度为1为止。
const arr = [5, 2, 1, 3, 6, 8, 4, 5, 7, 0, 15];
function hillFun(arr) {
  //第一层循环，确定间隔数
  // 这里的 gap 相当于插入排序中的 1 ，所以在第二层循环中 preIndex = i-gap; 相当于插入排序中的 preIndex = g - 1;
  for (
    let gap = parseInt(arr.length / 2);
    gap > 0;
    gap = parseInt(gap / 2)
  ) {
    //第二层循环，使用插入排序
    for (let i = gap; i < arr.length; i++) {
      let preIndex = i - gap;
      let current = arr[i];
      while (preIndex >= 0 && current < arr[preIndex]) {
        arr[preIndex + gap] = arr[preIndex];
        preIndex -= gap;
      }
      arr[preIndex + gap] = current;
    }
  }
  return arr;
}
const hillAns = hillFun(arr);
console.log(hillAns, "----------------------希尔排序");
// [0, 1, 2, 3, 4, 5, 5, 6, 7, 8, 15] '----------------------希尔排序'
```

### 二分查找

二分查找，也称为折半查找,二分查找采用分治策略，首先比较数组中间的元素与目标值，如果中间元素正好是目标值，则查找结束；如果目标值大于或小于中间元素，则在数组大于或小于中间元素的那一半部分继续查找，直到找到目标值或确定目标值不存在于数组中。二分查找的时间复杂度在最坏情况下为O(logn)，其中n是数组的长度。

- **适用场景**：二分查找特别适用于有序数组，并且在数据量较小的情况下效率更高，因为它能够保证在最坏情况下的时间复杂度为O(logn)。
```
function binarySearch(arr, target) {
      let left = 0, right = arr.length - 1;
      while (left <= right) {
          let mid = Math.floor((left + right) / 2);
          if (arr[mid] === target) {
              return mid; // 找到目标，返回索引
          } else if (arr[mid] < target) {
              left = mid + 1; // 在右半区继续查找
          } else {
              right = mid - 1; // 在左半区继续查找
          }
      }
      return -1; // 未找到目标，返回-1
  }

  // 示例使用
  const myArray = [1, 3, 5, 7, 9];
  console.log(binarySearch(myArray, 3)); // 输出: 1
  console.log(binarySearch(myArray, 6)); // 输出: -1
```
### 3. 实现 call、apply 及 bind 函数（建议看一下鲨鱼哥的掘金手写）

**（1）call 函数的实现步骤：**

*   判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
*   判断传入上下文对象是否存在，如果不存在，则设置为 window 。
*   处理传入的参数，截取第一个参数后的所有参数。
*   将函数作为上下文对象的一个属性。
*   使用上下文对象来调用这个方法，并保存返回结果。
*   删除刚才新增的属性。
*   返回结果。
```javascript
Function.prototype.myCall = function(context) {
  // 判断调用对象
  if (typeof this !== "function") {
    console.error("type error");
  }
  // 获取参数
  let args = [...arguments].slice(1),
    result = null;
  // 判断 context 是否传入，如果未传入则设置为 window
  context = context || window;
  // 将调用函数设为对象的方法
  context.fn = this;
  // 调用函数
  result = context.fn(...args);
  // 将属性删除
  delete context.fn;
  return result;
};
```
**（2）apply 函数的实现步骤：**

*   判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
*   判断传入上下文对象是否存在，如果不存在，则设置为 window 。
*   将函数作为上下文对象的一个属性。
*   判断参数值是否传入
*   使用上下文对象来调用这个方法，并保存返回结果。
*   删除刚才新增的属性
*   返回结果
```javascript
Function.prototype.myApply = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  let result = null;
  // 判断 context 是否存在，如果未传入则为 window
  context = context || window;
  // 将函数设为对象的方法
  context.fn = this;
  // 调用方法
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  // 将属性删除
  delete context.fn;
  return result;
};
```
**（3）bind 函数的实现步骤：**

*   判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
*   保存当前函数的引用，获取其余传入参数值。
*   创建一个函数返回
*   函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。
```javascript
Function.prototype.myBind = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  // 获取参数
  var args = [...arguments].slice(1),
    fn = this;
  return function Fn() {
    // 根据调用方式，传入不同绑定值
    return fn.apply(
      this instanceof Fn ? this : context,
      args.concat(...arguments)
    );
  };
};
```
### 节流

```javascript

```
### 节流

```javascript

```

### 节流

```javascript

```
### 节流

```javascript

```

### 节流

```javascript

```
### 节流

```javascript

```

### 节流

```javascript

```
### 节流

```javascript

```

### 节流

```javascript

```
### 节流

```javascript

```

### 节流

```javascript

```
### 节流

```javascript

```

### 节流

```javascript

```
### 节流

```javascript

```

### 节流

```javascript

```

# 数组
## 数组扁平化

```
function flatten(arr) {
  let result = [];

  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      result = result.concat(flatten(arr[i]));
    } else {
      result = result.concat(arr[i]);
    }
  }

  return result;
}

const a = [1, [2, [3, 4]]];
console.log(flatten(a));
```

## forEach
对数组的每个元素执行一次给定的函数。

- item：遍历项
- index：遍历项的索引
- arr：数组本身
```
  var players = [
    { name: "科比", num: 24 },
    { name: "詹姆斯", num: 23 },
    { name: "保罗", num: 3 }
  ]

  Array.prototype.my_forEach = function (callback) {
    for (let i = 0; i < this.length; i++) {
      callback(this[i], i, this);
    }
  }

  var res = players.my_forEach((item, index, arr) => {
    console.log(item, index);
  });
  console.log('res', res)
  // { name: '科比', num: 24 } 0
  // { name: '詹姆斯', num: 23 } 1
  // { name: '保罗', num: 3 } 2
```
## map
创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值

- item：遍历项
- index：遍历项的索引
- arr：数组本身
```
 var arr = [1, 2, 3, 4, 5];
 
 Array.prototype.my_map = function (callback) {
    const res = [];
    for (let i = 0; i < this.length; i++) {
      res.push(callback(this[i], i, this));
    }
    return res;
  };

  var result = arr.my_map(function (item, index, array) {
    console.log(index, item, array);
    return item * 2;
  });
 console.log('result',result)
 // [2, 4, 6, 8, 10]
 
```

## filter
创建一个新数组, 其包含通过所提供函数实现的测试的所有元素

- item：遍历项
- index：遍历项的索引
- arr：数组本身
```
var arr = [1, 2, 3, 4, 5];

  Array.prototype.my_filter = function (callback) {
    const res = [];
    for (let i = 0; i < this.length; i++) {
      callback(this[i], i, this) && res.push(this[i]);
    }
    return res;
  };

  console.log( arr.my_filter((item) => item > 3));  
  // [4, 5]
```
## every
检测数组所有元素是否都符合判断条件。返回一个布尔值。

- item：遍历项
- index：遍历项的索引
- arr：数组本身

```
 var players = [
    { name: "科比", num: 24 },
    { name: "詹姆斯", num: 23 },
    { name: "保罗", num: 3 }
  ]

 Array.prototype.my_every = function (callback) {
    let flag = true;
    for (let i = 0; i < this.length; i++) {
      flag = callback(this[i], i, this);
      if (!flag) break;
    }

    return flag;
  };

  console.log(players.my_every((item) => item.num >= 23)); // false
  console.log(players.my_every((item) => item.num >= 0)); // true
```

## some
检测数组中的是否有满足判断条件的元素。它返回的是一个Boolean类型的值。有一项返回true,则停止遍历

- item：遍历项
- index：遍历项的索引
- arr：数组本身
```
Array.prototype.my_some = function (callback) {
    let flag = false
    for (let i = 0; i < this.length; i++) {
        flag = callback(this[i], i, this)
        if (flag) break
    }

    return flag
}

console.log(players.my_some(item => item.num >= 23)) // true
console.log(players.my_some(item => item.num >= 50)) // false
```

## reduce
对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。

- pre：前一项
- next：下一项
- index：当前索引
- arr：数组本身

```
var players = [
        { name: "科比", num: 24 },
        { name: "詹姆斯", num: 23 },
        { name: "保罗", num: 3 },
      ];
      
Array.prototype.my_reduce = function (callback, ...args) {
    let start = 0, pre
    if (args.length) {
        pre = args[0]
    } else {
        pre = this[0]
        start = 1
    }
    for (let i = start; i < this.length; i++) {
        pre = callback(pre, this[i], i, this)
    }
    return pre
}

// 计算所有num相加
const sum = players.my_reduce((pre, next) => {
    return pre + next.num
}, 0)
console.log(sum) // 50
```
## findIndex
返回数组中匹配的第一个元素的索引。若没有找到对应元素则返回-1

- item：遍历项
- index：遍历项的索引
- arr：数组本身

```
var players = [
    { name: "科比", num: 24 },
    { name: "詹姆斯", num: 23 },
    { name: "保罗", num: 3 },
  ];

  Array.prototype.my_findIndex = function (callback) {
    for (let i = 0; i < this.length; i++) {
      if (callback(this[i], i, this)) {
        return i;
      }
    }
    return -1;
  };

  console.log(players.my_findIndex((item) => item.name === "科比")); // 0
  console.log(players.my_findIndex((item) => item.name === "安东尼")); // -1
```

## find
返回数组中满足提供的测试函数的第一个元素的值.找不到则返回undefined

- item：遍历项
- index：遍历项的索引
- arr：数组本身

```
var players = [
    { name: "科比", num: 24 },
    { name: "詹姆斯", num: 23 },
    { name: "保罗", num: 3 },
  ];
  
  Array.prototype.my_find = function (callback) {
    for (let i = 0; i < this.length; i++) {
      if (callback(this[i], i, this)) {
        return this[i];
      }
    }
    return undefined;
  };

  console.log(players.my_find((item) => item.name === "科比")); // { name: '科比', num: 24 }
  console.log(players.my_find((item) => item.name === "安东尼")); // undefined
```
## fill
用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。

- initValue：填充的值
- start：开始填充索引，默认0
- end：结束填充索引，默认length
```
var players = [
    { name: "科比", num: 24 },
    { name: "詹姆斯", num: 23 },
    { name: "保罗", num: 3 },
  ];
  var arr = [1, 2, 3, 4, 5]

  Array.prototype.sx_fill = function (value, start = 0, end) {
    end = end || this.length;
    for (let i = start; i < end; i++) {
      this[i] = value;
    }
    return this;
  };

  console.log(players.sx_fill("测试", 1, 3));  
  // [{name: '科比', num: 24},"测试", "测试"]
  console.log(arr.sx_fill(9))
  // [9, 9, 9, 9, 9]
```
## includes
用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。

```
Array.prototype.my_includes = function (value, start = 0) {
    if (start < 0) start = this.length + start;
    const isNaN = Number.isNaN(value);
    for (let i = start; i < this.length; i++) {
      if (this[i] === value || (isNaN && Number.isNaN(this[i]))) {
        return true;
      }
    }
    return false;
  };

  console.log([1, 2, 3].my_includes(2)); // true
  console.log([1, 2, 3, NaN].my_includes(NaN)); // true
  console.log([1, 2, 3].my_includes(1, 1)); // false
```

##  join
将数组用分隔符拼成字符串，分隔符默认为,

```
Array.prototype.my_join = function (s = ",") {
    let str = "";
    for (let i = 0; i < this.length; i++) {
      str = i === 0 ? `${str}${this[i]}` : `${str}${s}${this[i]}`;
    }
    return str;
  };

  console.log([1, 2, 3].my_join()); // 1,2,3
  console.log([1, 2, 3].my_join("*")); // 1*2*3
```
## flat
扁平化嵌套数组

```
Array.prototype.my_flat = function () {
    let arr = this;
    while (arr.some((item) => Array.isArray(item))) {
      arr = [].concat(...arr);
    }
    return arr;
  };

  const testArr = [1, [2, 3, [4, 5]], [8, 9]];

  console.log(testArr.my_flat());  // [1, 2, 3, 4, 5, 8, 9]
```

## splice （有问题）


```
Array.prototype.my_splice = function (start, length, ...values) {
    if (length === 0) return []
    length = start + length > this.length - 1 ? this.length - start : length
    console.log(length)
    const res = [], tempArr = [...this]
    for (let i = start; i < start + values.length; i++) {
        this[i] = values[i - start]
    }
    this.length = start + values.length
    if (values.length < length) {
        const cha = length - values.length
        console.log(cha)
        for (let i = start + values.length; i < tempArr.length; i++) {
        this[i] = tempArr[i + cha]
        }
        this.length = this.length - cha 
    }
    if (values.length > length) {
        for (let i = start + length; i < tempArr.length; i++) {
        this.push(tempArr[i])
        }
    }
    for (let i = start; i < start + length; i++) {
        res.push(tempArr[i])
    }
    return res
    }


  var arr = [1, 2, 3, 4, 5];

  console.log(arr.my_splice(1, 3, 0)); // [1, 0, 5]
//   console.log(arr.my_splice(-1)); // [1, 2, 3, 4]
```

# object

## assign

assign接收多个对象，并将多个对象合成一个对象     
这些对象如果有重名属性，以后来的对象属性值为准    
assign返回一个对象，这个对象 === 第一个对象     
```
Object.prototype.my_assign = function (target, ...args) {
    if (target === null || target === undefined) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    target = Object(target);

    for (let nextObj of args) {
      for (let key in nextObj) {
        nextObj.hasOwnProperty(key) && (target[key] = nextObj[key]);
      }
    }
    return target;
  };

  const testA = { name: "林三心" };
  const testB = { name: "sunshine_lin", age: 22 };
  const testC = { age: 18, gender: "男" };

  const testD = Object.my_assign(testA, testB, testC);
  console.log(testD); // { name: 'sunshine_lin', age: 18, gender: '男' }
  console.log(testA === testD); // true
```


## entries

将对象转成键值对数组

```
  var obj = {
    name: "张三",
    age: 22,
    gender: "男",
  };

  Object.prototype.my_entries = function (obj) {
    const res = [];
    for (let key in obj) {
      obj.hasOwnProperty(key) && res.push([key, obj[key]]);
    }
    return res;
  };

  console.log(Object.my_entries(obj));
  // [ [ 'name', '张三' ], [ 'age', 22 ], [ 'gender', '男' ] ]
```

## fromEntries
跟entries相反，将键值对数组转成对象

```
Object.prototype.my_fromEntries = function (arr) {
    const obj = {};
    for (let i = 0; i < arr.length; i++) {
      const [key, value] = arr[i];
      obj[key] = value;
    }
    return obj;
  };

  console.log(Object.my_fromEntries([['name', '张三'], ['age', 22], ['gender', '男']]))
  // { name: '张三', age: 22, gender: '男' }
```

## keys
将对象的key转成一个数组合集

```
var obj = {
    name: "张三",
    age: 22,
    gender: "男",
  };

  Object.prototype.my_keys = function (obj) {
    const keys = [];
    for (let key in obj) {
      obj.hasOwnProperty(key) && keys.push(key);
    }
    return keys;
  };

  console.log(Object.my_keys(obj));  // ['name', 'age', 'gender']
```

## values
将对象的所有值转成数组合集

```
Object.prototype.my_values = function (obj) {
    const values = [];
    for (let key in obj) {
      obj.hasOwnProperty(key) && values.push(obj[key]);
    }
    return values;
  };

  console.log(Object.my_values(obj)); // ['张三', 22, '男']
```
## instanceOf

```
  function instanceOf(father, child) {
    const fp = father.prototype;
    var cp = child.__proto__;

    while (cp) {
      if (cp === fp) {
        return true;
      }
      cp = cp.__proto__;
    }

    return false;
  }

  function Person(name) {
    this.name = name;
  }
  const sx = new Person("林三心");

  console.log(instanceOf(Person, sx)); // true
  console.log(instanceOf(Person, sx2)); // false
```

## Object.is
Object.is(a, b)，判断a是否等于b

```
Object.prototype.my_is = function (x, y) {
    if (x === y) {
      // 防止 -0 和 +0
      return x !== 0 || 1 / x === 1 / y;
    }

    // 防止NaN
    return x !== x && y !== y;
  };

  const a = { name: "张三" };
  const b = a;
  const c = { name: "张三" };

  console.log(Object.my_is(a, b)); // true
  console.log(Object.my_is(a, c)); // false
```
# Function
## call

```
  Function.prototype.my_call = function (obj, ...args) {
    obj = obj || window;

    // Symbol是唯一的，防止重名key
    const fn = Symbol();
    obj[fn] = this;

    // 执行，返回执行值
    return obj[fn](...args);
  };

  const testObj = {
    name: "张三",
    testFn(age) {
      console.log(`${this.name}-${age}岁了`);
    },
  };
  const testObj2 = {
    name: "zhang",
  };

  testObj.testFn.my_call(testObj2, 22); // zhang-22岁了
  testObj.testFn.call(testObj2, 22) // zhang-22岁了
```

## apply

```
Function.prototype.my_apply = function (obj, args) {
    obj = obj || window;

    // Symbol是唯一的，防止重名key
    const fn = Symbol();
    obj[fn] = this;

    // 执行，返回执行值
    return obj[fn](...args);
  };

  const testObj = {
    name: "张三",
    testFn(age) {
      console.log(`${this.name}-${age}岁了`);
    },
  };
  const testObj2 = {
    name: "zhang",
  };

  testObj.testFn.my_apply(testObj2, [22]); // zhang-22岁了
  testObj.testFn.apply(testObj2, [22])   // zhang-22岁了
```

## bind(报错)

```
 Function.prototype.my_bind = function (obj, ...args) {
    obj = obj || window;

    // Symbol是唯一的，防止重名key
    const fn = Symbol();
    obj[fn] = this;
    const _this = this;

    const res = function (...innerArgs) {
      console.log(this, _this);
      if (this instanceof _this) {
        this[fn] = _this;
        this[fn](...[...args, ...innerArgs]);
        delete this[fn];
      } else {
        obj[fn](...[...args, ...innerArgs]);
        delete obj[fn];
      }
    };
    res.prototype = Object.create(this.prototype);
    return res;
  };

  const testObj = {
    name: "张三",
    testFn(age) {
      console.log(`${this.name}-${age}岁了`);
    },
  };
  const testObj2 = {
    name: "zhang",
  };

  testObj.testFn.my_bind(testObj2, 22)(); // zhang-22岁了
```

# String

## slice

```
参数代表含义

start：开始截取的字符索引(包含此字符)
end：结束截取的字符索引(不包含此字符)

注意点
start > end：返回空字符串
start < 0：start = 数组长度 + start
```

```
  var str = "hello world";
  
  String.prototype.my_slice = function (start = 0, end) {
    start = start < 0 ? this.length + start : start;
    end = !end && end !== 0 ? this.length : end;

    if (start >= end) return "";
    let str = "";
    for (let i = start; i < end; i++) {
      str += this[i];
    }

    return str;
  };

  console.log(str.my_slice(2)); // llo world
  console.log(str.my_slice(-2)); // ld
  console.log(str.my_slice(-9, 10)); // llo worl
  console.log(str.my_slice(5, 1)); // ''
```
## substr

```
参数代表含义

start：开始截取的字符索引(包含此字符)
length：截取的长度

注意点

start < 0：start = 数组长度 + start
length超出所能截取范围，需要做处理
length < 0：返回空字符串
```

```
var str = "hello world";

String.prototype.my_substr = function (start = 0, length) {
    if (length < 0) return ''

    start = start < 0 ? this.length + start : start
    length = (!length && length !== 0) || length > this.length - start ? this.length : start + length

    let str = ''
    for (let i = start; i < length; i++) {
        str += this[i]
    }
    return str
}

console.log(str.my_substr(3)) // lo world
console.log(str.my_substr(3, 3)) // lo 
console.log(str.my_substr(5, 300)) // ' world'
```
# substring

```
功能与slice大致相同

区别之处

start > end：互换值
```

```
  var str = "hello world";

  String.prototype.my_substring = function (start = 0, end) {
    start = start < 0 ? this.length + start : start;
    end = !end && end !== 0 ? this.length : end;

    if (start >= end) [start, end] = [end, start];
    let str = "";
    for (let i = start; i < end; i++) {
      str += this[i];
    }

    return str;
  };

  console.log(str.my_substring(2)); // llo world
  console.log(str.my_substring(-2)); // ld
  console.log(str.my_substring(-9, 10)); // llo worl
  console.log(str.my_substring(5, 1)); // ello
```

# promise

## all （没测试）

接收一个Promise数组，数组中如有非Promise项，则此项当做成功  
如果所有Promise都成功，则返回成功结果数组   
如果有一个Promise失败，则返回这个失败结果    

```
function all(promises) {
    const result = []
    let count = 0
    return new MyPromise((resolve, reject) => {
        const addData = (index, value) => {
            result[index] = value
            count++
            if (count === promises.length) resolve(result)
        }
        promises.forEach((promise, index) => {
            if (promise instanceof MyPromise) {
                promise.then(res => {
                    addData(index, res)
                }, err => reject(err))
            } else {
                addData(index, promise)
            }
        })
    })
}
```
## race （没测试）

接收一个Promise数组，数组中如有非Promise项，则此项当做成功
哪个Promise最快得到结果，就返回那个结果，无论成功失败


```
function race(promises) {
    return new MyPromise((resolve, reject) => {
        promises.forEach(promise => {
            if (promise instanceof MyPromise) {
                promise.then(res => {
                    resolve(res)
                }, err => {
                    reject(err)
                })
            } else {
                resolve(promise)
            }
        })
    })
}
```
## allSettled （没测试）

接收一个Promise数组，数组中如有非Promise项，则此项当做成功   
把每一个Promise的结果，集合成数组，返回  

```
function allSettled(promises) {
    return new Promise((resolve, reject) => {
        const res = []
        let count = 0
        const addData = (status, value, i) => {
            res[i] = {
                status,
                value
            }
            count++
            if (count === promises.length) {
                resolve(res)
            }
        }
        promises.forEach((promise, i) => {
            if (promise instanceof MyPromise) {
                promise.then(res => {
                    addData('fulfilled', res, i)
                }, err => {
                    addData('rejected', err, i)
                })
            } else {
                addData('fulfilled', promise, i)
            }
        })
    })
}
```

## any （没测试）
any与all相反

接收一个Promise数组，数组中如有非Promise项，则此项当做成功  
如果有一个Promise成功，则返回这个成功结果   
如果所有Promise都失败，则报错    


```
function any(promises) {
    return new Promise((resolve, reject) => {
        let count = 0
        promises.forEach((promise) => {
            promise.then(val => {
                resolve(val)
            }, err => {
                count++
                if (count === promises.length) {
                    reject(new AggregateError('All promises were rejected'))
                }
            })
        })
    })
   }
}
```

