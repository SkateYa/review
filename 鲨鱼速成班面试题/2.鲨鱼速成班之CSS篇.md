目录

***

[TOC]

***

## 自己整理CSS面试题
### line-height和heigh区别
line-height是每一行文字的高，如果文字换行则整个盒子高度会增大（行数*行高）。
height是一个死值，就是这个盒子的高度。

### flex布局

https://www.ruanyifeng.com/blog/2015/07/flex-examples.html

**容器的属性**

> **flex-direction**    主轴的方向(row | row-reverse | column | column-reverse)
> **flex-wrap**           是否换行(nowrap | wrap | wrap-reverse)
> **flex-flow**              flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap
> **justify-content**    主轴上的对齐方式（flex-start | flex-end | center | space-between | space-around）
> **align-items**           在交叉轴上如何对齐（flex-start | flex-end | center | baseline | stretch）
> **align-content**      多根轴线的对齐方式(交叉轴)。如果项目只有一根轴线，该属性不起作用（flex-start | flex-end | center | space-between | space-around | stretch），比justify-content属性多了一个stretch属性

baseline: 项目的第一行文字的基线对齐。
stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

**项目的属性**

> **order**  项目的排列顺序。数值越小，排列越靠前，**默认为0**
> **flex-grow**  定义项目的放大比例，**默认为0**，即如果存在剩余空间，也不放大。
> **flex-shrink**  属性定义了项目的缩小比例，**默认为1**，即如果空间不足，该项目将缩小。
> **flex-basis**  定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为**auto**，即项目的本来大小
> **flex**  是flex-grow, flex-shrink 和 flex-basis的简写，**默认值为0 1 auto**。后两个属性可选，该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。**flex：1 是flex: 1 1 0%的简写，flex子项将根据可用空间进行增长或缩小，并且其基本大小为0。**
> 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。
> **align-self**  允许单个项目有与其他项目不一样的对齐方式(交叉轴)，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch（auto | flex-start | flex-end | center | baseline | stretch），属性取6个值，除了auto，比align-items属性多了一个auto属性

如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
负值对该属性无效。

**align-content** 
![image](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png)
**align-self** 
![image](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png)

### 标准模型与IE模型的区别

    现在最常用的是IE盒模型
    box-sizing：content-box；设置为标准盒子模型
    标准盒模型下盒子的大小 = width(content)+ border + padding + margin
    box-sizing：border-box；设置为IE盒子模型
    IE盒模型下盒子的大小=width（content + border + padding） + margin

### 行内元素和块级元素

block

占满一行，默认继承父元素的宽度；多个块元素将从上到下进行排列；
设置 width/height 将会生效；
设置 padding 和 margin 将会生效；

inline

不会占满一行，宽度随着内容而变化；多个 inline 元素将按照从左到右的顺序在一行里排列显示，如果一行显示不下，则自动换行；
设置 width/height 将不会生效；
设置竖直方向上的 padding 和 margin 将不会生效；

inline-block

是行内块元素，不单独占满一行，可以看成是能够在一行里进行左右排列的块元素；
设置 width/height 将会生效；
设置 padding 和 margin 将会生效；

### css继承

CSS 属性很多，但并不是所有的属性默认都是能继承父元素对应属性的，那哪些属性存在默认继承的行为呢？一定是那些不会影响到页面布局的属性，可以分为如下几类：

字体相关：font-family、font-style、font-size、font-weight 等；
文本相关：text-align、text-indent、text-decoration、text-shadow、letter-spacing、word-spacing、white-space、line-height、color 等；
列表相关：list-style、list-style-image、list-style-type、list-style-position 等；
其他属性：visibility、cursor 等；

对于其他默认不继承的属性也可以通过以下几个属性值来控制继承行为：

    inherit：继承父元素对应属性的计算值；
    initial：应用该属性的默认值，比如 color 的默认值是 #000；
    unset：如果属性是默认可以继承的，则取 inherit 的效果，否则同 initial；
    revert：效果等同于 unset，兼容性差。

### scss的特性

1.  通过\$符号去声明一个变量。
2.  嵌套
3.  引入 @import
4.  混合 @mixin @include  (相当于声明一个函数,传值)
5.  继承 @extend
6.  操作符 +、-、\*、/、% 对宽度进行简单的计算。
7.  引用父级选择器"&"  "&"必须出现在复合选择器开头的位置

### bfc

<https://blog.csdn.net/sinat_36422236/article/details/88763187>
BFC(Block formatting context)直译为"块级格式化上下文"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。
是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。



BFC（会计格式化上下文），一个创建了新的 BFC 的盒子是独立布局的，盒子内元素的布局不会影响盒 子外面的元素。在同一个 BFC 中的两个相邻的盒子在垂直方向发生 margin 重叠的问题。

BFC 是值浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布 局，这个渲染区域只对块级元素起作用



如何创建BFC

1.  float的值不是none。（left,right）
2.  position的值absolute、fixed
3.  display的值是inline-block、table-cell、flex、table-caption或者inline-flex
4.  overflow 除了 visible 以外的值 (hidden、auto、scroll)

```
float: left | right | none | inline-start | inline-end
position: static | relative | absolute | sticky | fixed
overflow: visible | hidden | clip | scroll | auto 
```

BFC的作用

1.  利用BFC避免margin重叠。（给其中一个元素外层加一个div，给div设置overflow: hidden;）
2.  自适应两栏布局（给不浮动的元素设置overflow: hidden;）
3.  清楚浮动 （给父元素设置overflow: hidden;）

### Css选择器有哪些? 哪些属性可以继承？

    css选择器有：
        - id选择器
        - 类选择器
        - 标签
        - 相邻选择器(h1+p)
        - 子选择器(ul>li)
        - 后代选择器(li a)
        - 通配符选择器(*)
        - 属性选择器（a[rel = "XXX"]）
        - 伪类选择器( :hover :first-child ···)
        - 伪元素选择器( :before :after ···)
        - 分组选择器
        
    可继承的样式：font-size, font-family, color，ul，li，dl，dt，dd；
    
    不可继承的样式：border, padding, margin, width, height

### Css选择器优先级

!important > 内联style > id > class > tag

优先级算法：

1.  同权重情况下样式定义最近者为准（优先级相同，选择最后出现的样式）
2.  元素选择符的权值：元素标签（派生选择器）：1，class选择符：10，id选择符：100，内联样式权值最大，为1000
3.  继承得到的样式的优先级最低

### css3新特性

1.  颜色：新增RGBA，HSLA模式

2.  文字阴影（text-shadow、）

3.  边框： 圆角（border-radius）边框阴影： box-shadow

4.  盒子模型：box-sizing

5.  背景：background-size 设置背景图片的尺寸background-origin 设置背景图片的原点
    background-clip 设置背景图片的裁切区域，以”，”分隔可以设置多背景，用于自适应布局

6.  渐变：linear-gradient、radial-gradient

7.  过渡：transition，可实现动画

8.  自定义动画

9.  在CSS3中唯一引入的伪元素是 ：：selection.

10. 媒体查询，多栏布局

11. border-image

12. 2D转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)

13. 3D转换

### 两栏布局

     <style>
          .outer {
            height: 100px;
          }
          /* .left {
            float: left;
            width: 200px;
            background: tomato;
          }
          .right {
            margin-left: 200px;
            width: auto;
            background: gold;
          } */
    
          /* .left {
            width: 100px;
            height: 200px;
            background: red;
            float: left;
          }
          .right {
            height: 300px;
            background: blue;
            overflow: hidden;
          } */
    
          /* .content {
            display: flex;
            height: 100px;
          }
          .left {
            width: 200px;
            background: tomato;
          }
          .right {
            flex: 1;
            background: gold;
          } */
    
          /* .content {
            position: relative;
            height: 100px;
          }
          .left {
            position: absolute;
            width: 200px;
            height: 100px;
            background: tomato;
          }
          .right {
            margin-left: 200px;
            background: gold;
          } */
    
          .content {
            position: relative;
            height: 100px;
          }
          .left {
            width: 200px;
            background: tomato;
          }
          .right {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 200px;
            background: gold;
          }
        </style>


​        
​        <div class="content">
​          <div class="outer left"></div>
​          <div class="outer right"></div>
​        </div>

### 三栏布局

### 元素上下左右都居中

### clearn:both的具体作用是什么

### 为什么要清除浮动,不清除浮动会造成什么影响

会影响下面的标准流盒子。

### 清楚浮动的几种方式

为什么要清除浮动呢？清除浮动的本质是什么？
清除浮动主要是为了解决父级元素因为子级浮动引起的内部高度为0的问题。

    1.给父元素后面加个div,设置clear:both;即可。
    优点：通俗易懂，书写方便。（不推荐使用）
    缺点：添加许多无意义的标签，结构化比较差。
    2.父级添加overflow方法：可以通过触发BFC的方式，实现清楚浮动效果
    优点：代码简洁（慎重使用，若该父盒子里还有position定位会引起麻烦）
    缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。
    3.利用 ::after 伪元素清理浮动
    优点：符合闭合浮动思想，结构语义化正确
    缺点：由于IE6-7不支持：after，使用zoom：1，触发hasLayout。
    .clearfix:after { 
        content: '.'; 
        display: block; 
        clear: both; 
    }
    4.使用before和after双伪元素清除浮动 (给父元素加个clearfix类)
     .clearfix:after,.clearfix:before{
            content: "";
            display: table;
        }
        .clearfix:after{
            clear: both;
        }

```
一、父级添加overflow: hidden；
　　　子元素浮动了，会造成父元素的高度坍塌。只要给父元素添加overflow: hidden;属性，就可以解决浮动带来的影响。


<ul class="cc">
    <li></li>
    <li></li>
</ul>
<style type="text/css">
    li {
        list-style: none;
        height: 100px;
        width: 100px;
        float: left;
        background: red;
        margin-left: 20px;
    }
    
    ul {
        overflow: hidden;
        padding: 0;
        margin: 0;
        background: pink;
    }
</style>

二、通过属性clear:both;达到清除浮动的目的；
　　元素浮动后，只需要在浮动元素添加多一个块级元素，并添加clear: both;属性，便可以达到清除浮动的目的。

<style type="text/css">
    li {
        list-style: none;
        height: 100px;
        width: 100px;
        float: left;
        background: red;
        margin-left: 20px;
    }
    ul{
        background: pink;
    }
</style>
<ul class="cc">
    <li></li>
    <li></li>
    <div style="clear: both;"></div>
</ul>

三、通过给父级元素添加伪类after，达到清除浮动的目的；
　　这种方式也是使用clear: both;的方式达到效果，只是变相的使用了伪类after，使得页面结构更简洁，也是常用的清理浮动的方式。


 li {
        list-style: none;
        height: 100px;
        width: 100px;
        float: left;
        background: red;
        margin-left: 20px;
      }

      .cc:after {
        content: "";
        display: block;
        clear: both;
      }
      ul {
        background: pink;
      }
    </style>
    <ul class="cc">
      <li></li>
      <li></li>
    </ul>
    
四、使用双伪类；
　　此方式和三原理一样，代码更简洁。
　　
<style type="text/css">
    li {
        list-style: none;
        height: 100px;
        width: 100px;
        float: left;
        background: red;
        margin-left: 20px;
    }
    
    .cc:after,
    .cc:before {
        content: "";
        display: block;
        clear: both;
    }
    
    ul {
        background: pink;
    }
</style>
<ul class="cc">
    <li></li>
    <li></li>
</ul>

```

### 水平垂直居中

水平居中文档：<https://www.zcfy.cc/article/centering-in-css-a-complete-guide-css-tricks>\
盒子水平和垂直居中的5大方案

已知元素的宽高

1.  absolute + 负margin
2.  absolute + auto margin
3.  absolute calc
    未知宽度
4.  display:flex
5.  transform

<!---->

```javascript
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>三栏布局</title>
  <link rel="stylesheet" href="">
  <style type="text/css" media="screen">
    html * {
      margin: 0;
      padding: 0;
    }
  </style>
</head>

<body>
  <section class="absolute margin">
    <style type="text/css" media="screen">
      /* 需要知道元素的宽高 */
      .absolute.margin .wrapper>div {
        min-height: 100px;
      }

      .absolute.margin .outer {
        position: relative;
        width: 100%;
        height: 200px;
        background: red;
      }

      .absolute.margin .inner {
        position: absolute;
        width: 100px;
        height: 100px;
        background: yellow;
        left: 50%;
        top: 50%;
        margin-left: -50px;
        margin-top: -50px;
      }
    </style>
    <article class="wrapper">
      <div class="outer">
        <div class="inner">absolute + 负margin 需要知道元素的宽高 </div>
      </div>
    </article>
  </section>
```


      <section class="absolute auto margin">
        <style type="text/css" media="screen">
          .absolute.auto.margin .outer {
            position: relative;
            width: 100%;
            height: 200px;
            background: rgb(224, 195, 195);
          }
    
          .absolute.auto.margin .inner {
            position: absolute;
            width: 100px;
            height: 100px;
            background: yellow;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            margin: auto;
    
          }
        </style>
        <article class="wrapper">
          <div class="outer">
            <div class="inner">absolute auto margin 需要知道元素的宽高 </div>
          </div>
        </article>
      </section>


      <section class="absolute calc">
        <style type="text/css" media="screen">
          .absolute.calc .outer {
            position: relative;
            width: 100%;
            height: 200px;
            background: rgb(104, 119, 189);
          }
    
          .absolute.calc .inner {
            position: absolute;
            width: 100px;
            height: 100px;
            background: yellow;
            left: calc(50% - 50px);
            top: calc(50% - 50px);
          }
        </style>
        <article class="wrapper">
          <div class="outer">
            <div class="inner">absolute calc 需要知道元素的宽高</div>
          </div>
        </article>
      </section>
    
      <section class="absolute transform">
        <style type="text/css" media="screen">
          .absolute.transform .outer {
            position: relative;
            width: 100%;
            height: 200px;
            background: rgb(226, 97, 97);
          }
    
          .absolute.transform .inner {
            position: absolute;
            background: yellow;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
          }
        </style>
        <article class="wrapper">
          <div class="outer">
            <div class="inner">absolute transform 不需要知道子元素宽高 </div>
          </div>
        </article>
      </section>
    
      <section class="flex">
        <style type="text/css" media="screen">
          .flex .outer {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 300px;
            background: rgb(57, 15, 211);
          }
    
          .flex .inner {
            background: yellow;
          }
        </style>
        <article class="wrapper">
          <div class="outer">
            <div class="inner">flex 不需要知道子元素宽高 </div>
          </div>
        </article>
      </section>
    
      <section class="table">
        <style type="text/css" media="screen">
          .table .outer {
            display: table-cell;
            width: 800px;
            height: 300px;
            text-align: center;
            vertical-align: middle;
            background: red;
          }
    
          .table .inner {
            display: inline-block;
            width: 100px;
            height: 100px;
            background: yellow;
          }
        </style>
        <article class="wrapper">
          <div class="outer">
            <div class="inner">table 需要知道子元素宽高 </div>
          </div>
        </article>
      </section>
      
      <section class="grid">
        <style type="text/css" media="screen">
          .grid .outer {
            display: grid;
            align-content: center;
            justify-content: center;
            width: 100%;
            height: 300px;
            background: rgb(17, 201, 109);
          }
    
          .grid .inner {
            background: rgb(38, 0, 255);
          }
        </style>
        <article class="wrapper">
          <div class="outer">
            <div class="inner">grid 不需要知道子元素宽高 </div>
          </div>
        </article>
      </section>
    </body>
    
    </html>

### 实现一个宽高都是200px的div上下左右居中

<https://juejin.im/post/5eace2176fb9a04340658974>
<https://www.jianshu.com/p/7d7cf4f051ee>

如果去掉高度已知，只有flex布局和table布局可以用
面试时至少写出三种哦。接下来问题可能会有三个延伸方向：

### 三栏布局

每种方案的优缺点？
如果高度不固定，实践中一般用哪种？
以上几种方案的兼容性如何？

每种布局的优缺点

1.  float margin布局
    优点：比较简单，兼容性也比较好。只要清除浮动做的好，是没有什么问题的\
    缺点：浮动元素是脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如高度塌陷等。
2.  绝对布局
    优点：很快捷，设置很方便，而且也不容易出问题\
    缺点：绝对定位是脱离文档流的，意味着下面的所有子元素也会脱离文档流，这就导致了这种方法的有效性和可使用性是比较差的。
3.  flex 布局
    优点：简单快捷
    缺点：不支持 IE8 及以下
4.  table布局
    优点：实现简单，代码少\
    缺点：当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的。
5.  grid布局
    跟 flex 相似。

<!---->

    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>三栏布局</title>
        <link rel="stylesheet" href="">
        <style type="text/css" media="screen">
            html *{
                margin: 0;
                padding: 0;
            }
        </style>
    </head>
    <body>
        <section class="layout float">
            <style type="text/css" media="screen">
                .layout.float .wrapper>div{
                    min-height: 100px;
                }
                .layout.float .left{
                    float: left;
                    width: 300px;
                    background: red;
                }
                .layout.float .center{
                    background: yellow;
                     margin: 0 300px 0 300px;
                }
                .layout.float .right{
                    float: right;
                    width: 300px;
                    background: blue;
                }
                
            </style>
            <article class="wrapper">
                <div class="left"></div>
                <div class="right"></div>
                <div class="center">
                    <h1>float布局</h1>
                    1.我是float布局的中间部分
                    2.我是float布局的中间部分
                </div>
            </article>
        </section>


        <section class="layout absolute">
            <style type="text/css" media="screen">
                .layout.absolute .wrapper{
                    width: 100%;
                    margin-top: 20px;
                }
                .layout.absolute .wrapper>div{
                    min-height: 100px;
                }
                .layout.absolute .left{
                    position: absolute;
                    left: 0;
                    width: 300px;
                    background: red;
                }
                .layout.absolute .center{
                    position: absolute;
                    left: 300px;
                    right: 300px;
                    background: yellow;
                }
                .layout.absolute .right{
                    position: absolute;
                    right: 0;
                    width: 300px;
                    background: blue;
                }
            </style>
            <article class="wrapper">
                <div class="left"></div>
                <div class="center">
                    <h1>absolute布局</h1>
                    1.我是absolute布局的中间部分
                    2.我是absolute布局的中间部分
                </div>
                <div class="right"></div>
            </article>
        </section>


        <section class="layout flex">
            <style type="text/css" media="screen">
                .layout.flex .wrapper{
                    width: 100%;
                    min-height: 100px;
                    display: flex;
                    margin-top: 140px;
                }
                .layout.flex .left{
                    width: 300px;
                    background: red;
                }
                .layout.flex .center{
                    flex: 1;
                    background: yellow;
                }
                .layout.flex .right{
                    width: 300px;
                    background: blue;
                }
            </style>
            <article class="wrapper">
                <div class="left"></div>
                <div class="center">
                    <h1>flex布局</h1>
                    1.我是flex布局的中间部分
                    2.我是flex布局的中间部分
                </div>
                <div class="right"></div>
            </article>
        </section>


        <section class="layout table">
            <style type="text/css" media="screen">
                .layout.table .wrapper{
                    display: table;
                    width: 100%;
                    min-height: 100px;
                    margin-top: 20px;
                }
                .layout.table .left{
                    display: table-cell;
                    width: 300px;
                    background: red;
                }
                .layout.table .center{
                    display: table-cell;
                    background: yellow;
                }
                .layout.table .right{
                    display: table-cell;
                    width: 300px;
                    background: blue;
                }
                
            </style>
            <article class="wrapper">
                <div class="left"></div>
                <div class="center">
                    <h1>table布局</h1>
                    1.我是table布局的中间部分
                    2.我是table布局的中间部分
                </div>
                <div class="right"></div>
            </article>
        </section>


        <section class="layout grid">
            <style type="text/css" media="screen">
                .layout.grid .wrapper{
                    display: grid;
                    grid-template-columns: 300px auto 300px;
                    grid-template-rows: 100px;
                    width: 100%;
                    margin-top: 20px;
                }
                .layout.grid .left{
                    background: red;
                }
                .layout.grid .center{
                    background: yellow;
                }
                .layout.grid .right{
                    background: blue;
                }
                
            </style>
            <article class="wrapper">
                <div class="left"></div>
                <div class="center">
                    <h1>grid布局</h1>
                    1.我是grid布局的中间部分
                    2.我是grid布局的中间部分
                </div>
                <div class="right"></div>
            </article>
        </section>
    </body>
    </html>


## 一、CSS 基础
### display: none;与visibility: hidden;的区别
1. 占用位置的区别
display: none; 				是不占用位置的
visibility: hidden;   虽然隐藏了，但是占用位置

2. 重绘和回流的问题

visibility: hidden; 、 display: none;  产生重绘
display: none;     还会产生一次回流

产生回流一定会造成重绘，但是重绘不一定会造成回流。

产生回流的情况：改变元素的位置(left、top...)、显示隐藏元素....
产生重绘的情况：样式改变、换皮肤

### 常用的伪元素包括：

1. ::before：在元素内容的前面插入内容。
2. ::after：在元素内容的后面插入内容。
3. ::first-letter：选择元素内容的第一个字母。
4. ::first-line：选择元素内容的第一行。
5. ::selection：选择元素被用户选中的部分。
6. ::placeholder：选择表单元素的占位符文本。
7. ::marker：选择列表项的标记部分。
8. ::backdrop：选择全屏模态框的背景层。
9. ::cue：选择媒体元素的提示文本。
10. ::spelling-error：选择拼写错误的文本。
11. ::grammar-error：选择语法错误的文本。

### 移动端适配不同屏幕尺寸的方法如下：

1. 使用响应式布局：通过使用CSS3的媒体查询，根据不同的屏幕尺寸设置不同的CSS样式，使得页面可以自适应不同的屏幕尺寸。

2. 使用弹性布局：通过设置元素的宽度为百分比或使用flex布局，使得页面可以根据不同的屏幕尺寸自动调整元素的大小和位置。

3. 使用rem单位：使用rem单位代替px单位，根据屏幕宽度动态计算字体大小和元素宽度，使得页面可以自适应不同的屏幕尺寸。

4. 使用viewport：设置meta viewport标签，指定页面的宽度和缩放比例，使得页面可以在不同的屏幕尺寸下呈现相同的效果。

5. 使用图片适配：使用不同尺寸的图片资源，根据不同的屏幕尺寸加载相应的图片，使得页面可以在不同的屏幕尺寸下呈现相同的图片效果。

### css加载
css加载不会阻塞DOM树的解析
css加载会阻塞DOM树的渲染
css加载会阻塞后面js语句的执行

可以改变顺序来避免阻塞
因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:

使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)
对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)
合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)
减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)

### height:100%和height:auto的区别

height:auto，是指根据块内内容自动调节高度。
height:100%，是指其相对父块高度而定义的高度，也就是按照离它最近且有定义高度的父层的高度来定义高度。

###  怎么让Chrome支持小于12px的文字
    常见的解决方案有：
    zoom：变焦；  
    -webkit-transform:scale()：放缩；
    -webkit-text-size-adjust:none：根据设备(浏览器)来自动调整显示大小。


    zoom: 0.8;
    -webkit-transform:scale(0.8);
    -webkit-text-size-adjust:none
-----------------------------------------------------------------------


    -webkit-text-size-adjust:none
    该属性用来设定文字大小是否根据设备(浏览器)来自动调整显示大小
    
    属性值：
    
    percentage：字体显示的大小；
    auto：默认，字体大小会根据设备/浏览器来自动调整；
    none:字体大小不会自动调整
    
    这样设置之后会有一个问题，就是当你放大网页时，一般情况下字体也会随着变大，而设置了以上代码后，字体只会显示你当前设置的字体大小，不会随着网页放大而变大了
    
    所以，我们不建议全局应用该属性，而是单独对某一属性使用
    
    需要注意的是，自从chrome 27之后，就取消了对这个属性的支持。同时，该属性只对英文、数字生效，对中文不生效

### scoped的原理
```
为组件实例生成一个唯一标识，给组件中的每个标签对应的dom元素添加一个标签属性，data-v-xxxx
给<style scoped>中的每个选择器的最后一个选择器添加一个属性选择器，原选择器[data-v-xxxx]，如：原选择器为.container #id div，则更改后选择器为.container #id div[data-v-xxxx]
```
### 1. CSS 选择器及其优先级

| **选择器**     | **格式**      | **优先级权重** |
| -------------- | ------------- | -------------- |
| id 选择器      | #id           | 100            |
| 类选择器       | .classname    | 10             |
| 属性选择器     | a\[ref=“eee”] | 10             |
| 伪类选择器     | li:last-child | 10             |
| 标签选择器     | div           | 1              |
| 伪元素选择器   | li::after     | 1              |
| 相邻兄弟选择器 | h1+p          | 0              |
| 子选择器       | ul>li         | 0              |
| 后代选择器     | li a          | 0              |
| 通配符选择器   | *            | 0              |

1.后代选择器会选中指定标签中，所有的特定后代标签，也就是会选中儿子，孙子，只有放到标签中的特定标签都能选中

2.子元素选择器只会选中指定标签中，所有特定的直接标签，也就是只会选中特定的儿子标签


对于选择器的**优先级**：

*   标签选择器、伪元素选择器：1
*   类选择器、伪类选择器、属性选择器：10
*   id 选择器：100
*   内联样式：1000

**注意事项：**

*   !important 声明的样式的优先级最高；
*   如果优先级相同，则最后出现的样式生效；
*   继承得到的样式的优先级最低；
*   通用选择器（\*）、子选择器（>）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；
*   样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式。

CSS属性哪些可以继承：
文字系列：font-size、color、line-height、text-align...
***不可继承属性：border、padding、margin...


字体及其相关属性：font、font-family、font-size、font-style、font-variant、font-weight、font-stretch、font-size-adjust。
文本相关属性：color、direction、letter-spacing、line-height、text-align、text-decoration、text-indent、text-shadow、text-transform、unicode-bidi、white-space、word-spacing。
列表属性：list-style、list-style-image、list-style-position、list-style-type。
表格布局属性：border-collapse、caption-side、empty-cells、table-layout。
可见性属性：visibility。
光标属性：cursor。
注意：虽然这些属性可以继承，但是否实际继承取决于元素的类型和上下文。


大多数CSS属性都是不可继承的，例如：

盒模型相关属性：width、height、margin、padding、border。
定位属性：position、top、right、bottom、left、float、clear、overflow、clip、vertical-align。
背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment。
轮廓属性：outline、outline-width、outline-color、outline-style。
布局和显示属性：display、visibility（虽然可以继承，但在某些情况下其效果可能不如预期）。
边框属性：border-width、border-color、border-style。
这些只是不可继承属性的一部分，实际上CSS中有大量的属性都是不可继承的。

记住这些规则很重要，因为它们会影响你如何组织和编写CSS代码。在设计样式时，你需要考虑到哪些属性需要显式地设置在每个元素上，哪些属性可以通过继承得到。


### 4. display 的 block、inline 和 inline-block 的区别
（1）**block：**会独占一行，多个元素会另起一行，可以设置 width、height、margin 和 padding 属性；
（2）**inline：**元素不会独占一行，设置 width、height 属性无效。padding，margin都不能设置垂直方向，左右可以设置；
（3）**inline-block：**将对象设置为 inline 对象，但对象的内容作为 block 对象呈现，之后的内联对象会被排列在同一行内。

对于行内元素和块级元素，其特点如下：

**（1）行内元素**

*   设置宽高无效；
*   padding，margin都不能设置垂直方向，左右可以设置；
*   不会自动换行；

**（2）块级元素**

*   可以设置宽高；
*   设置 margin 和 padding 都有效；
*   可以自动换行；
*   多个块状，默认排列从上到下。

### 6. link 和@import 的区别

两者都是外部引用 CSS 的方式，它们的区别如下：

*   link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。
*   link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。
*   link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持。
*   link 支持使用 Javascript 控制 DOM 去改变样式；而@import 不支持。

```javascript
<link rel="stylesheet" href="demo.css">
 <style>
@import url(demo. css); 
</style>
```
### 8. display:none 与 visibility:hidden 的区别

这两个属性都是让元素隐藏，不可见。两者**区别如下：**

（1）**在渲染树中**

- `display:none`会让元素完全从渲染树中消失，渲染时不会占据任何空间；不会触发该元素绑定的事件
- `visibility:hidden`不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。不会触发该元素绑定的事件
- `opacity:0 `元素隐藏，不会改变页面布局，并且，如果该元素已经绑定了一些事件，如：click,那么点击该区域，也能触发点击事件

（2）是否是**继承属性**

- `display:none`是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；
- `visibility:hidden`是继承属性，子孙节点消失是由于继承了`hidden`，通过设置`visibility:visible`可以让子孙节点显示；
- `opacity` 继承

（3）修改常规文档流中元素的 `display` 通常会造成文档的重排，但是修改`visibility`属性只会造成本元素的重绘；

（4）如果使用读屏器，设置为`display:none`的内容不会被读取，设置为`visibility:hidden`的内容会被读取。

### 9. **伪元素和伪类的区别和作用？**

*   伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：

```css
p::before {
  content: "第一章：";
}
p::after {
  content: "Hot!";
}
p::first-line {
  background: red;
}
p::first-letter {
  font-size: 30px;
}
```

*   伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：

```css
a:hover {
  color: #ff00ff;
}
p:first-child {
  color: red;
}
```

**总结：**伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。

### 11. 对盒模型的理解

CSS3 中的盒模型有以下两种：标准盒子模型、IE 盒子模型

![image](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820746-e10daafa-451a-454e-9705-f8c358769d5b.png#align=left\&display=inline\&height=366\&margin=%5Bobject%20Object%5D\&originHeight=455\&originWidth=746\&size=0\&status=done\&style=none\&width=600)

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820555-dc6ed390-d47e-412b-942a-857bbe5f280d.png?x-oss-process=image%2Fresize%2Cw_746#align=left\&display=inline\&height=368\&margin=%5Bobject%20Object%5D\&originHeight=462\&originWidth=791\&size=0\&status=done\&style=none\&width=630)

盒模型都是由四个部分组成的，分别是 margin、border、padding 和 content。

标准盒模型和 IE 盒模型的区别在于设置 width 和 height 时，所对应的范围不同：

*   标准盒模型的 width 和 height 属性的范围只包含了 content，
*   IE 盒模型的 width 和 height 属性的范围包含了 border、padding 和 content。

可以通过修改元素的 box-sizing 属性来改变元素的盒模型：

*   `box-sizing: content-box`表示标准盒模型（默认值）
*   `box-sizing: border-box`表示 IE 盒模型（怪异盒模型）

### 13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？

浏览器会把 inline 内联元素间的空白字符（空格、换行、Tab 等）渲染成一个空格。为了美观，通常是一个`<li>`放在一行，这导致`<li>`换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。

**解决办法：**

（1）为`<li>`设置 float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。

（2）将所有`<li>`写在同一行。不足：代码不美观。

（3）将`<ul>`内的字符尺寸直接设为 0，即 font-size:0。不足：`<ul>`中的其他字符尺寸也被设为 0，需要额外重新设定其他字符尺寸，且在 Safari 浏览器依然会出现空白间隔。

（4）消除`<ul>`的字符间隔 letter-spacing:-8px，不足：这也设置了`<li>`内的字符间隔，因此需要将`<li>`内的字符间隔设为默认 letter-spacing\:normal。

### 14. CSS3 中有哪些新特性

https://www.runoob.com/css3/css3-borders.html

CSS3的新特性大致分为以下六大类

1.CSS3选择器 (属性选择器,子选择器,相邻兄弟选择器,通用兄弟选择器,群组选择器 )

2.CSS3边框与圆角（border-radius:8px）

3.CSS3背景与渐变(background-image,gradient）

4.CSS3过渡(transition)

5.CSS3转换(transform)

6.CSS3动画(animation)

7.弹性盒子(flex)

8.多媒体类型(@media)

9.文本效果（text-shadow）

*   新增各种 CSS 选择器 （`: not(.input)`：所有 class 不是“input”的节点）
*   圆角 （border-radius:8px）
*   多列布局 （multi-column layout）
*   阴影和反射 （Shadoweflect）
*   文字特效 （text-shadow）
*   文字渲染 （Text-decoration）
*   线性渐变 （gradient）
*   旋转 （transform）
*   增加了旋转,缩放,定位,倾斜,动画,多背景

### 16. 常见的图片格式及使用场景--简单了解一下

（1）**BMP**，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以 BMP 格式的图片通常是较大的文件。

（2）**GIF**是无损的、采用索引色的点阵图。采用 LZW 压缩算法进行编码。文件小，是 GIF 格式的优点，同时，GIF 格式还具有支持动画以及透明的优点。但是 GIF 格式仅支持 8bit 的索引色，所以 GIF 格式适用于对色彩要求不高同时需要文件体积较小的场景。

（3）**JPEG**是有损的、采用直接色的点阵图。JPEG 的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG 非常适合用来存储照片，与 GIF 相比，JPEG 不适合用来存储企业 Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较 GIF 更大。

（4）**PNG-8**是无损的、使用索引色的点阵图。PNG 是一种比较新的图片格式，PNG-8 是非常好的 GIF 格式替代者，在可能的情况下，应该尽可能的使用 PNG-8 而不是 GIF，因为在相同的图片效果下，PNG-8 具有更小的文件体积。除此之外，PNG-8 还支持透明度的调节，而 GIF 并不支持。除非需要动画的支持，否则没有理由使用 GIF 而不是 PNG-8。

（5）**PNG-24**是无损的、使用直接色的点阵图。PNG-24 的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24 格式的文件大小要比 BMP 小得多。当然，PNG24 的图片还是要比 JPEG、GIF、PNG-8 大得多。

（6）**SVG**是无损的矢量图。SVG 是矢量图意味着 SVG 图片由直线和曲线以及绘制它们的方法组成。当放大 SVG 图片时，看到的还是线和曲线，而不会出现像素点。SVG 图片在放大时，不会失真，所以它适合用来绘制 Logo、Icon 等。

（7）**WebP**是谷歌开发的一种新图片格式，WebP 是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为 Web 而生的，什么叫为 Web 而生呢？就是说相同质量的图片，WebP 具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有 Chrome 浏览器和 Opera 浏览器支持 WebP 格式，兼容性不太好。

*   在无损压缩的情况下，相同质量的 WebP 图片，文件大小要比 PNG 小 26%；
*   在有损压缩的情况下，具有相同图片精度的 WebP 图片，文件大小要比 JPEG 小 25%\~34%；
*   WebP 图片格式支持图片透明度，一个无损压缩的 WebP 图片，如果要支持透明度只需要 22%的格外文件大小。

### 21. CSS 优化和提高性能的方法有哪些？

**加载性能：**

（1）css 压缩：将写好的 css 进行打包压缩，可以减小文件体积。

（2）css 单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但 margin-bottom:bottom;margin-left:left;执行效率会更高。

（3）减少使用@import，建议使用 link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。

**选择器性能：**

（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS 选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；

（2）如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。

（3）避免使用通配规则，如\*{}计算次数惊人，只对需要用到的元素进行选择。

（4）尽量少的去对标签进行选择，而是用 class。

（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。

（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。

**渲染性能：**

（1）慎重使用高性能属性：浮动、定位。

（2）尽量减少页面重排、重绘。

（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少 css 文档体积。

（4）属性值为 0 时，不加单位。

（5）属性值为浮动小数 0.\*\*，可以省略小数点之前的 0。

（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。

（7）不使用@import 前缀，它会影响 css 的加载速度。

（8）选择器优化嵌套，尽量避免层级过深。

（9）css 雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。

（10）正确使用 display 的属性，由于 display 的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。

（11）不滥用 web 字体。对于中文网站来说 WebFonts 可能很陌生，国外却很流行。web fonts 通常体积庞大，而且一些浏览器在下载 web fonts 时会阻塞页面渲染损伤性能。

**可维护性、健壮性：**

（1）将具有相同属性的样式抽离出来，整合并通过 class 在页面中进行使用，提高 css 的可维护性。

（2）样式与内容分离：将 css 代码定义到外部 css 中。

### 22. CSS 预处理器/后处理器是什么？为什么要使用它们？

**预处理器**，如：`less`，`sass`，`stylus`，用来预编译`sass`或者`less`，增加了`css`代码的复用性。层级，`mixin`， 变量，循环， 函数等对编写以及开发 UI 组件都极为方便。

**后处理器，** 如： `postCss`，通常是在完成的样式表中根据`css`规范处理`css`，让其更加有效。目前最常做的是给`css`属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。

`css`预处理器为`css`增加一些编程特性，无需考虑浏览器的兼容问题，可以在`CSS`中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让`css`更加的简洁，增加适应性以及可读性，可维护性等。

其它`css`预处理器语言：`Sass（Scss）`, `Less`, `Stylus`, `Turbine`, `Swithch css`, `CSS Cacheer`, `DT Css`。

使用原因：

*   结构清晰， 便于扩展
*   可以很方便的屏蔽浏览器私有语法的差异
*   可以轻松实现多重继承
*   完美的兼容了`CSS`代码，可以应用到老项目中

### 23. ::before 和 :after 的双冒号和单冒号有什么区别？

（1）冒号(`:`)用于`CSS3`伪类，双冒号(`::`)用于`CSS3`伪元素。

（2）`::before`就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于`dom`之中，只存在在页面之中。

**注意：** `:before `和 `:after` 这两个伪元素，是在`CSS2.1`里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着`Web`的进化，在`CSS3`的规范里，伪元素的语法被修改成使用双冒号，成为`::before`、`::after`。

### 25. 单行、多行文本溢出隐藏

*   单行文本溢出

```css
overflow: hidden; // 溢出隐藏
text-overflow: ellipsis; // 溢出用省略号显示
white-space: nowrap; // 规定段落中的文本不进行换行
```

*   多行文本溢出

```css
overflow: hidden; // 溢出隐藏
text-overflow: ellipsis; // 溢出用省略号显示
display: -webkit-box; // 作为弹性伸缩盒子模型显示。
-webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列
-webkit-line-clamp: 3; // 显示的行数
```

注意：由于上面的三个属性都是 CSS3 的属性，不是所有浏览器都可以兼容，所以要在前面加一个`-webkit-` 来兼容一部分浏览器。

### 26. Sass、Less 是什么？为什么要使用他们？

他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。

**为什么要使用它们？**

*   结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。
*   可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。

### 27. 对媒体查询的理解？

媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃ CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合 web ⽹⻚应对不同型号的设备⽽做出对应的响应适配。

媒体查询包含⼀个可选的媒体类型和满⾜ CSS3 规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为 true 或 false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是 true，那么该媒体查询的结果为 true。那么媒体查询内的样式将会⽣效。

```css
<!-- link元素中的CSS媒体查询 -->
<link rel="stylesheet" media="(max-width: 800px)" href="example.css" />
<!-- 样式表中的CSS媒体查询 -->
<style>
@media (max-width: 600px) {
  .facet_sidebar {
    display: none;
  }
}
</style>
```

简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。

### 28. 对 CSS 工程化的理解

CSS 工程化是为了解决以下问题：

1.  **宏观设计**：CSS 代码如何组织、如何拆分、模块结构怎样设计？
2.  **编码优化**：怎样写出更好的 CSS？
3.  **构建**：如何处理我的 CSS，才能让它的打包结果最优？
4.  **可维护性**：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？

以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：

*   预处理器：Less、 Sass 等；
*   重要的工程化插件： PostCss；
*   Webpack loader 等 。

基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：

**（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？**

预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码：

![image](https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1615998492170-c294084b-84d5-4537-87bb-b32da4bf0cd6.jpeg)

那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：

1.  宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；
2.  编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；
3.  可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。

这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：

*   嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；
*   支持定义 css 变量；
*   提供计算函数；
*   允许对代码片段进行 extend 和 mixin；
*   支持循环语句的使用；
*   支持将 CSS 文件模块化，实现复用。

**（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？**

PostCss 仍然是一个对 CSS 进行解析和处理的工具，它会对 CSS 做这样的事情：

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1615998491947-34e3237c-e54f-4b1a-8aeb-3c38655e1cb0.jpeg?x-oss-process=image%2Fresize%2Cw_1038)

它和预处理器的不同就在于，预处理器处理的是 类 CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。

PostCss 在业务中的使用场景非常多：

*   提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；
*   当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 [Autoprefixer](https://github.com/postcss/autoprefixer) 插件可以帮助我们自动增加浏览器前缀；
*   允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；

**（3）Webpack 能处理 CSS 吗？如何实现？**

Webpack 能处理 CSS 吗：

*   **Webpack 在裸奔的状态下，是不能处理 CSS 的**，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；
*   Webpack 在 loader 的辅助下，是可以处理 CSS 的。

如何用 Webpack 实现对 CSS 的处理：

*   Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader

*   注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：
*   css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；
*   style-loader：创建 style 标签，把 CSS 内容写入标签。

在实际使用中，**css-loader 的执行顺序一定要安排在 style-loader 的前面**。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。

## 二、页面布局

### 2. px、em、rem 的区别及使用场景

### 相对单位

相对单位就是相对于另一个长度的长度。CSS中的相对单位主要分为两大类：

字体相对单位，他们都是根据font-size来进行计算的。常见的字体相对单位有：em、rem、ex、ch；
视窗相对单位，他们都是根据视窗大小来决定的。常见的视窗相对单位有vw、vh、vmax、vmin。

**三者的区别：**

*   px 是固定的像素，一旦设置了就无法因为适应页面大小而改变。
*   em 和 rem 相对于 px 更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。
*   em 是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而 rem 是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。

**使用场景：**

*   对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用 px 即可 。
*   对于需要适配各种移动设备，使用 rem，例如需要适配 iPhone 和 iPad 等分辨率差别比较挺大的设备。

### 4. 三栏布局的实现

三栏布局一般指的是页面中一共有三栏，**左右两栏宽度固定，中间自适应的布局**，三栏布局的具体实现：

*   利用**绝对定位**，左右两栏设置为绝对定位，中间设置对应方向大小的 margin 的值。

```css
.outer {
  position: relative;
  height: 100px;
}

.left {
  position: absolute;
  width: 100px;
  height: 100px;
  background: tomato;
}

.right {
  position: absolute;
  top: 0;
  right: 0;
  width: 200px;
  height: 100px;
  background: gold;
}

.center {
  margin-left: 100px;
  margin-right: 200px;
  height: 100px;
  background: lightgreen;
}
```

*   利用 flex 布局，左右两栏设置固定大小，中间一栏设置为 flex:1。

```css
.outer {
  display: flex;
  height: 100px;
}

.left {
  width: 100px;
  background: tomato;
}

.right {
  width: 100px;
  background: gold;
}

.center {
  flex: 1;
  background: lightgreen;
}
```

*   利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的 margin 值，注意这种方式\*\*，中间一栏必须放到最后：\*\*

```css
.outer {
  height: 100px;
}

.left {
  float: left;
  width: 100px;
  height: 100px;
  background: tomato;
}

.right {
  float: right;
  width: 200px;
  height: 100px;
  background: gold;
}

.center {
  height: 100px;
  margin-left: 100px;
  margin-right: 200px;
  background: lightgreen;
}
```

*   圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。

```css
.outer {
  height: 100px;
  padding-left: 100px;
  padding-right: 200px;
}

.left {
  position: relative;
  left: -100px;

  float: left;
  margin-left: -100%;

  width: 100px;
  height: 100px;
  background: tomato;
}

.right {
  position: relative;
  left: 200px;

  float: right;
  margin-left: -200px;

  width: 200px;
  height: 100px;
  background: gold;
}

.center {
  float: left;

  width: 100%;
  height: 100px;
  background: lightgreen;
}
```

*   双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。

```css
.outer {
  height: 100px;
}

.left {
  float: left;
  margin-left: -100%;

  width: 100px;
  height: 100px;
  background: tomato;
}

.right {
  float: left;
  margin-left: -200px;

  width: 200px;
  height: 100px;
  background: gold;
}

.wrapper {
  float: left;

  width: 100%;
  height: 100px;
  background: lightgreen;
}

.center {
  margin-left: 100px;
  margin-right: 200px;
  height: 100px;
}
```

### 5.水平垂直居中的实现

*   利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 translate 来调整元素的中心点到页面的中心。该方法需要**考虑浏览器兼容问题。**

```css
.parent {
  position: relative;
}

.child {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}
```

*   利用绝对定位，设置四个方向的值都为 0，并将 margin 设置为 auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于**盒子有宽高**的情况：

```css
.parent {
  position: relative;
}

.child {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  margin: auto;
}
```

*   利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 margin 负值来调整元素的中心点到页面的中心。该方法适用于**盒子宽高已知**的情况

```css
.parent {
  position: relative;
}

.child {
  position: absolute;
  top: 50%;
  left: 50%;
  margin-top: -50px; /* 自身 height 的一半 */
  margin-left: -50px; /* 自身 width 的一半 */
}
```

*   使用 flex 布局，通过 align-items\:center 和 justify-content\:center 设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要**考虑兼容的问题**，该方法在移动端用的较多：

```css
.parent {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

另外，如果父元素设置了 flex 布局，只需要给子元素加上`margin:auto;`就可以实现垂直居中布局

```css
.parent {
  display: flex;
}
.child {
  margin: auto;
}
```

这里蛮有意思的 如果不在弹性布局中 `margin:auto;`只能做到水平居中

这其中的道理可以看[这篇文章](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fwuguidian1114%2Farticle%2Fdetails%2F105559117)了解一下（具体就是与 auto 的定义有关）

如果是行内元素 text-align：center； line-height: height;

### 6. 如何根据设计稿进行移动端适配？
移动端适配主要有两个维度：

- **设计稿尺寸**：首先需要确定设计稿的尺寸，比如iPhone 6的尺寸为750x1334px。这个尺寸可以作为移动端适配的基准。
- **像素密度**：不同移动设备的像素密度不同，需要根据设计稿的尺寸以及设备的像素密度来计算实际尺寸。
- **布局方式**：移动端的布局方式一般采用流式布局或弹性布局，以适应不同尺寸的设备。可以使用CSS3的弹性盒子布局或媒体查询来实现。
- **字体大小**：需要根据设备的屏幕尺寸和像素密度来确定合适的字体大小，以保证在不同设备上显示效果一致。
- **图片适配**：需要根据设备的像素密度来选择合适的图片，以避免图片模糊或失真。
- **适配不同屏幕大小，**由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。

为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。

### 7. 对 Flex 布局的理解及其使用场景

Flex 是 FlexibleBox 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。行内元素也可以使用 Flex 布局。注意，设为 Flex 布局以后，**子元素的 float、clear 和 vertical-align 属性将失效**。采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。

以下 6 个属性设置在**容器上**：

*   flex-direction 属性决定主轴的方向（即项目的排列方向）。
*   flex-wrap 属性定义，如果一条轴线排不下，如何换行。
*   flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。
*   justify-content 属性定义了项目在主轴上的对齐方式。
*   align-items 属性定义项目在交叉轴上如何对齐。
*   align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

以下 6 个属性设置在**项目上**：

*   order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。
*   flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。
*   flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。
*   flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。
*   flex 属性是 flex-grow，flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。
*   align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。

**简单来说：**

flex 布局是 CSS3 新增的一种布局方式，可以通过将一个元素的 display 属性值设置为 flex 从而使它成为一个 flex 容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用 flex-direction 来指定主轴的方向。可以使用 justify-content 来指定元素在主轴上的排列方式，使用 align-items 来指定元素在交叉轴上的排列方式。还可以使用 flex-wrap 来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用 order 属性来指定项目的排列顺序，还可以使用 flex-grow 来指定当排列空间有剩余的时候，项目的放大比例，还可以使用 flex-shrink 来指定当排列空间不足时，项目的缩小比例。

### 8.flex:1 是什么组成的  （重点）

flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto（后两个属性可选）。

**flex-basis** 设置子元素宽度。如果元素上同时设置了 width 和 flex-basis，那么 width 的值会被 flex-basis 覆盖掉。
**flex-grow** 父元素的宽度大于所有子元素的宽度的和时（即父元素会有剩余空间），子元素如何分配父元素的剩余空间。 flex-grow 的默认值为 0，意思是该元素不扩展父元素的剩余空间，如果值大于 0，表示扩展。值越大，扩展越大。
**flex-shrink**父元素的宽度小于所有子元素的宽度的和时（即子元素会超出父元素），子元素如何缩小自己的宽度的。 flex-shrink 的默认值为 1，当父元素的宽度小于所有子元素的宽度的和时，子元素的宽度会缩小。值越大，缩小的越厉害。如果值为 0，表示不缩小。

> flex:1 和 flex:auto 的区别

flex:1

    flex-grow : 1;
    flex-shrink : 1;
    flex-basis : 0%;

***

flex:auto

    flex-grow : 1;
    flex-shrink : 1;
    flex-basis : auto;

### 9.说说浏览器的 reflow（回流）和 repaint（重绘）

**reflow(回流)**
reflow 翻译为回流，指的是页面再次构建 render 树。每个页面至少发生一次回流，就是第一次加载页面的时候
此外，当页面中有任何改变可能造成文档结构发生改变(即元素间的相对或绝对位置改变)，都会发生 reflow，常见的有：

*   添加或删除元素(opacity:0 除外，它不是删除)
*   改变某个元素的尺寸或位置
*   浏览器窗口改变(resize 事件触发)

**repaint(重绘)**
repaint 翻译为重绘，它可以类比为上面的第四步，根据 render 树绘制页面，它的性能损耗比回流要小。每次回流一定会发生重绘。此外，以下操作(不影响文档结构的操作，影响结构的会发生回流)也会发生重绘：

*   元素的颜色、透明度改变
*   text-align 等

## 三、定位与浮动

### 1. 为什么需要清除浮动？清除浮动的方式

清除浮动的3种方式，常用的是前2种
1。 触发BFC
2。 after方式
```
  ul:after{
    content: "";
    display: block;
    clear: both;
  }
```
3。 多创建一个盒子，添加样式：clear： both；

**浮动的定义：** 非 IE 浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。

**浮动的工作原理：**

*   浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）
*   浮动元素碰到包含它的边框或者其他浮动元素的边框停留

浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。

**浮动元素引起的问题？**

*   父元素的高度无法被撑开，影响与父元素同级的元素
*   与浮动元素同级的非浮动元素会跟随其后
*   若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构

**清除浮动的方式如下：**

*   给父级 div 定义`height`属性
*   最后一个浮动元素之后添加一个空的 div 标签，并添加`clear:both`样式
*   包含浮动元素的父级标签添加`overflow:hidden`或者`overflow:auto`
*   使用 :after 伪元素。由于 IE6-7 不支持 :after，使用 zoom:1 触发 hasLayout\*\*

```css
.clearfix:after {
  content: "\200B";
  display: table;
  height: 0;
  clear: both;
}
.clearfix {
  *zoom: 1;
}
```

### 2. 使用 clear 属性清除浮动的原理？

使用 clear 属性清除浮动，其语法如下：

```css
clear: none|left|right|both;
```

如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。

官方对 clear 属性解释：“**元素盒子的边不能和前面的浮动元素相邻**”，对元素设置 clear 属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。

还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“**前面的**”3 个字，也就是 clear 属性对“后面的”浮动元素是不闻不问的。考虑到 float 属性要么是 left，要么是 right，不可能同时存在，同时由于 clear 属性对“后面的”浮动元素不闻不问，因此，当 clear:left 有效的时候，clear:right 必定无效，也就是此时 clear:left 等同于设置 clear:both；同样地，clear:right 如果有效也是等同于设置 clear:both。由此可见，clear:left 和 clear:right 这两个声明就没有任何使用的价值，至少在 CSS 世界中是如此，直接使用 clear\:both 吧。

一般使用伪元素的方式清除浮动：

```css
.clear::after {
  content: "";
  display: block;
  clear: both;
}
```

clear 属性只有块级元素才有效的，而::after 等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置 display 属性值的原因。

### 3. 对 BFC 的理解，如何创建 BFC

BFC就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。

1。 了解BFC：块级格式化上下文。

2。 BFc的原则：如果一个元素具有BFC，那么内部元素再怎么弄，都不会影响到外面的元素。

3。 如何触发BFC：

float的值非none

overflow的值非visible

display的值为：inline-block、 table-cell...

position的值为：absolute、 fixed

先来看两个相关的概念：

*   Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个 Box 就是我们所说的盒模型。
*   Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。

块格式化上下文（Block Formatting Context，BFC）是 Web 页面的可视化 CSS 渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。

通俗来讲：BFC 是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发 BFC 的条件，则 BFC 中的元素布局不受外部影响。


**创建 BFC 的条件：**

*   根元素：body；
*   元素设置浮动：float 除 none 以外的值；
*   元素设置绝对定位：position (absolute、fixed)；
*   display 值为：inline-block、table-cell、table-caption、flex 等；
*   overflow 值为：hidden、auto、scroll；

**BFC 的特点：**

*   垂直方向上，自上而下排列，和文档流的排列方式一致。
*   在 BFC 中上下相邻的两个容器的 margin 会重叠
*   计算 BFC 的高度时，需要计算浮动元素的高度
*   BFC 区域不会与浮动的容器发生重叠
*   BFC 是独立的容器，容器内部元素不会影响外部元素
*   每个元素的左 margin 值和容器的左 border 相接触

**BFC 的作用：**

*   **解决 margin 的重叠问题**：由于 BFC 是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个 BFC，就解决了 margin 重叠的问题。
*   **解决高度塌陷的问题**：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为 0。解决这个问题，只需要把父元素变成一个 BFC。常用的办法是给父元素设置`overflow:hidden`。
*   **创建自适应两栏布局**：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。

```css
.left{
     width: 100px;
     height: 200px;
     background: red;
     float: left;
 }
 .right{
     height: 300px;
     background: blue;
     overflow: hidden;
 }

<div class="left"></div>
<div class="right"></div>
```

左侧设置`float:left`，右侧设置`overflow: hidden`。这样右边就触发了 BFC，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。

### 4. 什么是 margin 重叠问题？如何解决？

**问题描述：**

两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，**浮动的元素和绝对定位**这种脱离文档流的元素的外边距不会折叠。重叠只会出现在**垂直方向**。

**计算原则：**

折叠合并后外边距的计算原则如下：

*   如果两者都是正数，那么就去最大者
*   如果是一正一负，就会正值减去负值的绝对值
*   两个都是负值时，用 0 减去两个中绝对值大的那个

**解决办法：**

对于折叠的情况，主要有两种：**兄弟之间重叠**和**父子之间重叠**

（1）兄弟之间重叠

*   底部元素变为行内盒子：`display: inline-block`
*   底部元素设置浮动：`float`
*   底部元素的 position 的值为`absolute/fixed`

（2）父子之间重叠

*   父元素加入：`overflow: hidden`
*   父元素添加透明边框：`border:1px solid transparent`
*   子元素变为行内盒子：`display: inline-block`
*   子元素加入浮动属性或定位

### 6. position 的属性有哪些，区别是什么

position 有以下属性值：

| 属性值      | 概述                                                                                        |
| -------- | ----------------------------------------------------------------------------------------- |
| absolute | 生成绝对定位的元素，相对于 static 定位以外的一个父元素进行定位。脱离文档流。元素的位置通过 left、top、right、bottom 属性进行规定。                 |
| relative | 生成相对定位的元素，相对于其原来的位置进行定位。不脱离文档流。元素的位置通过 left、top、right、bottom 属性进行规定。                             |
| fixed    | 生成绝对定位的元素，指定元素相对于浏览器窗口的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。            |
| static   | 默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。 |
| inherit  | 规定从父元素继承 position 属性的值                                                                    |


前面三者的定位方式如下：

*   \*\*relative：\*\*元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694939-58dfe7f7-2fc9-45e5-9961-a953f95496a7.png#align=left\&display=inline\&height=105\&margin=%5Bobject%20Object%5D\&originHeight=105\&originWidth=448\&size=0\&status=done\&style=stroke\&width=447)

\*\*fixed：\*\*元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694841-89472ba9-b236-4098-802f-c3c26ff49466.png#align=left\&display=inline\&height=117\&margin=%5Bobject%20Object%5D\&originHeight=135\&originWidth=516\&size=0\&status=done\&style=stroke\&width=446)

\*\*absolute：\*\*元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了`position:relative/absolute/fixed`的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694882-589670e0-cd52-41d4-a3ed-4ebbdfc88f32.png#align=left\&display=inline\&height=142\&margin=%5Bobject%20Object%5D\&originHeight=183\&originWidth=576\&size=0\&status=done\&style=stroke\&width=446)

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694842-2764d9ed-d5fe-45f4-8ede-34a73d237f94.png#align=left\&display=inline\&height=118\&margin=%5Bobject%20Object%5D\&originHeight=137\&originWidth=516\&size=0\&status=done\&style=stroke\&width=446)

### 7. link 与@import 区别与选择

    <style type="text/css">
     @import url(CSS文件路径地址);
    </style>
    <link href="CSSurl路径" rel="stylesheet" type="text/css" /

复制代码 link 功能较多，可以定义 RSS，定义 Rel 等作用，而@import 只能用于加载 css；
当解析到 link 时，页面会同步加载所引的 css，而@import 所引用的 css 会等到页面加载完才被加载；
@import 需要 IE5 以上才能使用；
link 可以使用 js 动态引入，@import 不行

## 四、场景应用--重点掌握

### 1. 实现一个三角形

CSS 绘制三角形主要用到的是 border 属性，也就是边框。

平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border 属性是右三角形组成的，下面看一个例子：

```css
div {
  width: 0;
  height: 0;
  border: 100px solid;
  border-color: orange blue red green;
}
```

将元素的长宽都设置为 0，显示出来的效果是这样的：

![image](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245125-d60dca78-0577-4aa1-8809-f1d38594889a.png#align=left\&display=inline\&height=298\&margin=%5Bobject%20Object%5D\&originHeight=502\&originWidth=1012\&size=0\&status=done\&style=stroke\&width=600)

所以可以根据 border 这个特性来绘制三角形：

**（1）三角 1**

```css
div {
  width: 0;
  height: 0;
  border-top: 50px solid red;
  border-right: 50px solid transparent;
  border-left: 50px solid transparent;
}
```

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245420-28c28277-5074-4725-9386-ffc955cf950a.png?x-oss-process=image%2Fresize%2Cw_500#align=left\&display=inline\&height=132\&margin=%5Bobject%20Object%5D\&originHeight=162\&originWidth=738\&size=0\&status=done\&style=stroke\&width=600)

**（2）三角 2**

```css
div {
  width: 0;
  height: 0;
  border-bottom: 50px solid red;
  border-right: 50px solid transparent;
  border-left: 50px solid transparent;
}
```

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245172-36f955bd-075b-442a-b88b-6c084c66ed25.png?x-oss-process=image%2Fresize%2Cw_500#align=left\&display=inline\&height=133\&margin=%5Bobject%20Object%5D\&originHeight=140\&originWidth=630\&size=0\&status=done\&style=stroke\&width=600)

**（3）三角 3**

```css
div {
  width: 0;
  height: 0;
  border-left: 50px solid red;
  border-top: 50px solid transparent;
  border-bottom: 50px solid transparent;
}
```

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245082-84a06746-dfc7-4782-a0d4-27d521aecac7.png?x-oss-process=image%2Fresize%2Cw_500#align=left\&display=inline\&height=195\&margin=%5Bobject%20Object%5D\&originHeight=210\&originWidth=646\&size=0\&status=done\&style=stroke\&width=600)

**（4）三角 4**

```css
div {
  width: 0;
  height: 0;
  border-right: 50px solid red;
  border-top: 50px solid transparent;
  border-bottom: 50px solid transparent;
}
```

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245064-ecd01197-99fc-476e-897f-a4165b55792a.png?x-oss-process=image%2Fresize%2Cw_500#align=left\&display=inline\&height=191\&margin=%5Bobject%20Object%5D\&originHeight=220\&originWidth=690\&size=0\&status=done\&style=stroke\&width=600)

**（5）三角 5**

```css
div {
  width: 0;
  height: 0;
  border-top: 100px solid red;
  border-right: 100px solid transparent;
}
```

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245095-5b40d585-7e68-4bb0-aaef-6c8fce7d36b8.png?x-oss-process=image%2Fresize%2Cw_500#align=left\&display=inline\&height=177\&margin=%5Bobject%20Object%5D\&originHeight=218\&originWidth=738\&size=0\&status=done\&style=stroke\&width=600)

还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。

### 2. 实现一个扇形

用 CSS 实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个 90° 的扇形：

```css
div {
  border: 100px solid transparent;
  width: 0;
  height: 0;
  border-radius: 100px;
  border-top-color: red;
}
```

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636444767-26da7bbe-5479-44e2-9088-50c9211d6c0d.png?x-oss-process=image%2Fresize%2Cw_500#align=left\&display=inline\&height=190\&margin=%5Bobject%20Object%5D\&originHeight=234\&originWidth=738\&size=0\&status=done\&style=none\&width=600)

### 3. 实现一个宽高自适应的正方形

*   利用 vw 来实现：

```css
.square {
  width: 10%;
  height: 10vw;
  background: tomato;
}
```

*   利用元素的 margin/padding 百分比是相对父元素 width 的性质来实现：

```css
.square {
  width: 20%;
  height: 0;
  <!--padding-top: 20%;-->
  padding-bottom: 20%; 
  background: orange;
}
```

*   利用子元素的 margin-top 的值来实现：

```css
.square {
  width: 30%;
  overflow: hidden;
  background: yellow;
}
.square::after {
  content: "";
  display: block;
  margin-top: 100%;
}
```

### 4. 画一条 0.5px 的线

*   **采用 transform: scale()的方式**，该方法用来定义元素的 2D 缩放转换：

```css
transform: scale(0.5, 0.5);
```

*   **采用 meta viewport 的方式**

```html
<meta
  name="viewport"
  content="width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5"
/>
```

这样就能缩放到原来的 0.5 倍，如果是 1px 那么就会变成 0.5px。viewport 只针对于移动端，只在移动端上才能看到效果

### 5. 设置小于 12px 的字体*

在谷歌下 css 设置字体大小为 12px 及以下时，显示都是一样大小，都是默认 12px。

**解决办法：**

*   使用 Webkit 的内核的-webkit-text-size-adjust 的私有 CSS 属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是 chrome 更新到 27 版本之后就不可以用了。所以高版本 chrome 谷歌浏览器已经不再支持-webkit-text-size-adjust 样式，所以要使用时候慎用。
*   使用 css3 的 transform 缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用 display：block/inline-block/...；
*   使用图片：如果是内容固定不变情况下，使用将小于 12px 文字内容切出做图片，这样不影响兼容也不影响美观。

### 6. 如何解决 1px 问题？

1px 问题指的是：在一些 `Retina屏幕` 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：

```js
window.devicePixelRatio = 设备的物理像素 / CSS像素。
```

打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 `devicePixelRatio` 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是 2：

![image](https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1615998119364-e2b81466-ba5b-4eb8-af5f-61c5621bb0af.jpeg?x-oss-process=image%2Fresize%2Cw_1500)

这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。

**解决\*\***1px 问题的三种思路：\*\*

#### 思路一：直接写 0.5px

如果之前 1px 的样式这样写：

```css
border: 1px solid #333;
```

可以先在 JS 中拿到 window\.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：

```html
<div id="container" data-device="{{window.devicePixelRatio}}"></div>
```

然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为 2 的情况：

```css
#container[data-device="2"] {
  border: 0.5px solid #333;
}
```

直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要 8 及以上的版本，安卓系统则直接不兼容。

#### 思路二：伪元素先放大后缩小

这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。

思路是**先放大、后缩小：\*\***在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的\***\*宽和高都设置为目标元素的两倍，border 值设为 1px。\*\***接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一\***\*，间接地实现了 0.5px 的效果。**

代码如下：

```css
#container[data-device="2"] {
    position: relative;
}
#container[data-device="2"]::after{
      position:absolute;
      top: 0;
      left: 0;
      width: 200%;
      height: 200%;
      content:"";
      transform: scale(0.5);
      transform-origin: left top;
      box-sizing: border-box;
      border: 1px solid #333;
    }
}
```

#### 思路三：viewport 缩放来解决

这个思路就是对 meta 标签里几个关键属性下手：

```html
<meta
  name="viewport"
  content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"
/>
```

这里针对像素比为 2 的页面，把整个页面缩放为了原来的 1/2 大小。这样，本来占用 2 个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：

```js
const scale = 1 / window.devicePixelRatio;
// 这里 metaEl 指的是 meta 标签对应的 Dom
metaEl.setAttribute(
  "content",
  `width=device-width,user-scalable=no,initial-scale=${scale},maximum-scale=${scale},minimum-scale=${scale}`
);
```

这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。
