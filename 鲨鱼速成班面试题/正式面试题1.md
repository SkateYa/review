```

```
目录
*****
[TOC]
*****
# 2024面试题整理
项目打包时间过长，体积过大优化
基本都会问前端错误监控上报！！http系列！！性能优化！！webpack！！

### Jenkins
### 
### 开发模式
（敏捷开发，瀑布式开发，螺旋型开发，迭代开发）
### 任务队列
任务队列（task queue）主要分两种
1、宏任务（macrotask）：在新标准中叫 task
主要包括：script(整体代码)，setTimeout，setInterval，setImmediate，I/O，ui rendering
2、微任务（microtask）：在新标准中叫 jobs
主要包括：process.nextTick， Promise.then，MutationObserver（html5 新特性）
3、扩展：
同步任务：在主线程上，排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
异步任务：不进入主线程，而进入“任务队列”的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行
### post和put请求的区别
### apply、call、bind
### promise和async，await的区别和使用场景
### webpack和vite的区别
### webpack的结构
### webpack的热更新
### webgl
### css预处理器，及优势
### promise原理
### 响应式布局
### 小程序，h5，pc端开发一套适配
uniapp,reactnative
### 元素隐藏有哪些方式和区别
### 盒子塌陷，如何避免
### 什么会造成内存泄露
### forEach和map的区别
###  
### 
### 
### 
### 
### 
###  
### 
### 
### 
### 
### 
###  
### 
### 


### application/x-www-form-urlencoded

[qs](https://so.csdn.net/so/search?q=qs&spm=1001.2101.3001.7020)是一个npm仓库所管理的包,可通过`npm install qs`命令进行安装（axios 自带qs , // import qs from 'qs'）

**qs.parse()将URL解析成对象的形式:**

```js
let url = 'user=wdx&pwd=123&appToken=7d22e38e-5717-11e7-907b-a6006ad3dba0'
qs.parse(url)
console.log(qs.parse(url)) 
// {user:'wdx',pwd:'123',appToken:'7d22e38e-5717-11e7-907b-a6006ad3dba0'}
```

**qs.stringify()将对象 序列化成URL的形式，以&进行拼接**

```javascript
qs.stringify 是把一个参数对象格式化为一个字符串。

let obj= {
    user:'wdx',
    pwd:'123',
    appToken:'7d22e38e-5717-11e7-907b-a6006ad3dba0'
}
qs.stringify(obj)
console.log(qs.stringify(obj)) 
// 'user=wdx&pwd=123&appToken=7d22e38e-5717-11e7-907b-a6006ad3dba0'
```

**qs.stringify详解**
content-type为application / x-www-form-urlencoded，必须使用axios将js对象序列化为json

```js
const qs = require('qs');
axios.post('/foo', qs.stringify({ 'bar': 123 }));
```

```js
import qs  from 'qs'
import axios from 'axios'
function getUserRouter(uid){
  return axios({
    url: 'http://localhost:3000/user_router_auth',
    method: 'post',
    header: {
        'content-type':'application/x-www-form-urlencoded'
    },
    data: qs.stringify({uid})
  }).then(res=>{
    return res.data
  }).catch(err=>{
    throw err
  })
}
```


### 性能优化 整理
https://blog.csdn.net/chaoPerson/article/details/130743570

一个网站加载性能如何主要看白屏时间和首屏时间。

- 白屏时间：指从输入网址，到页面开始显示内容的时间。
- 首屏时间：指从输入网址，到页面完全渲染的时间。

前端性能指标

前端性能优化是一个很大的话题，优化是循序渐进的

**性能指标**

FP 白屏（First Paint Time ）： （首次绘制）表示页面绘制第一个像素的时间
FCP 首屏（first contentful paint ）：（首次内容绘制）首屏渲染时间（表示渲染出第一个内容，这里的“内容”可以是文本、图片）
SI (Speed Index)：首屏展现时间
TTI (Time to Interactive)：（可交互时间）页面资源加载成功并能响应用户交互的时间点
TBT (Total Blocking Time)：（总阻塞时间）FCP到TTI之间,主线程被长任务(超过50ms)阻塞的时间之和
LCP (Largest Contentful Paint)：（最大内容绘制）显示最大内容元素所需时间 (衡量网站初次载入速度)
CLS (Cumulative Layout Shift)：累积布局偏移(衡量网页元件视觉稳定性)
FID（First input delay）： 首次输入延迟（用户第一次与页面交互到浏览器实际能够开始处理事件的时间）(衡量网站互动顺畅程度)

**SEO**。搜索引擎中的排名和可见性

白屏时间：即用户点击一个链接或打开浏览器输入URL地址后，从屏幕空白到显示第一个画面的时间。

**常见的几种SPA首屏优化方式**

- 减小入口文件积

- 静态资源本地缓存

- UI框架按需加载

- 图片资源的压缩

- 组件重复打包

  解决方案：在`webpack`的`config`文件中，修改`CommonsChunkPlugin`的配置

  ```
  1minChunks: 3
  ```

  `minChunks`为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件

- 开启GZip压缩

  compression-webpack-plugin

- 使用SSR



.非首屏组件使用异步组件1。使用路由懒加载

2。非首屏组件使用异步组件

3。首屏不中要的组件延迟加载

4。静态资源放在CDN上

5。减少首屏上JS、 css等资源文件的大小

6。 使用服务端渲染

7。简历减少DOM的数量和层级

8。使用精灵图请求

9。做一些1oading

10。开启Gzip压缩

11。图片懒加载
elementui 按需引入
monentjs用day.js来替代
服务端渲染（SSR）



1. 首屏速度，白屏时间等

   首屏速度 包括白屏时间，渲染页面时间

   资源加载时间，  首屏js执行
   渲染页面    首屏数据请求， dom渲染

   //现在打包工具-tree-shaking

   //把一些老版本的库替换成新版本，新版本的支持tree-shaking

   收效很大的操作

   1，减少首屏资源体积（打包工具的压缩，异步加载，更新为体积更小的新版本，能不用第三方库就不用第三库，编写代码尽量减少体积，去除大的base64体积）最大效果

   收效不大或者特殊情况的优化操作

   1，首屏数据尽量并行，如果可行让小数据量接口合并到其他接口

   2，页面包含大量dom可以分批随滚动渲染

   3，骨架屏，loading，先让屏幕不白，减少用户焦虑

2. 操作速度以及渲染速度

   什么情况下会造成操作卡顿和渲染慢 1， 一次性操作大量dom

   2，进行了复杂度很高的运算（常见于循环）

   3， vue和react项目中，不必要的渲染太多

   

   **vue优化**

   Vue中有依赖收集，配合上vue3的静态节点标记，已经基本上避免了因为数据改变引起的无意

   义渲染。只有一些小点可以参考回答

   频繁切换的显隐的内容用v-show也就是cisplay来控制隐藏，只有打开就一次性决定显示与否的用v-if

   不去创建

   2，循环，动态切换内容加好key值

   3 keep-alive缓存

   ，区分请求粒度，减少请求范围，也能减少更新

   vue优化:1)循环的时候使用正确的key 
   2)封装高度复用的模块 如请求 ；抽离高度复用的组件；组件可配置型强 
   3）路由懒加载，首屏加载快 
   4）produtionSourcemap设为false 生成map文件 定位源码 
   5）productionGzip 设为true 打包体积更小
   6）keepalive 缓存不活跃的组件
   7）插件使用CDN引入到html中
   8）图片放到cdn上 ，icon字体文件 
   9）组件按需导入 ，需要什么导入什么

   合理使用`watch`和`computed`，数据变化就会执行，避免使用太多，减少不必要的开销

   合理使用组件，提高代码可维护性的同事也会降低代码组件的耦合性

   使用路由懒加载，在需要的时候才会进行加载，避免一次性加载太多路由，导致页面阻塞

   使用`Vuex`缓存数据

   合理使用`mixins`，抽离公共代码封装成模块，避免重复代码。

   合理使用`v-if `、`v-show`

   `v-for `不要和`v-if`一起使用，`v-for`的优先级会比`v-if`高

   `v-for`中不要用`index`做`key`，要保证`key`的唯一性

   使用异步组件，避免一次性加载太多组件

   避免使用`v-html`，存在安全问风险和性能问题，可以使用`v-text`

   使用`keep-alive`缓存组件，避免组件重复加载

   

   

   ## HTML&CSS

   - 减少`DOM`数量，减轻浏览器渲染计算负担。
   - 使用异步和延迟加载`js`文件，避免`js`文件阻塞页面渲染
   - 压缩`HTML、CSS`代码体积，删除不要的代码，合并`CSS`文件，减少`HTTP`请求次数和请求大小。
   - 减少`CSS`选择器的复杂程度，复杂度与阿高浏览器解析时间越长。
   - 避免使用`CSS`表达式在`javascript`代码中
   - 使用`css`渲染合成层如`transform`、`opacity`、`will-change`等，提高页面相应速度减少卡顿现象。
   - 动画使用`CSS3`过渡，减少动画复杂度，还可以使用硬件加速。

   ## JS

   - 减少`DOM`操作数量
   - 避免使用`with`语句、`eval`函数，避免引擎难以优化。
   - 尽量使用原生方法，执行效率高。
   - 将`js`文件放到文件页面底部，避免阻塞页面渲染
   - 使用事件委托，减少事件绑定次数。
   - 合理使用缓存，避免重复请求数据。
   
   
   
   
   
   **`web`性能测试工具**
   
   11. Lighthouse

   详细的内容,可以去参考 git: https://github.com/GoogleChrome/lighthouse

   3.1.2 测试网站

   https://www.webpagetest.org/

   

   

    加载优化

   1。 加载优化
   
   1。 压缩合并
   
   2。 代码分制(code spliting)，可以基于路由或动态加载

   3。 第三方模块放在 CDN

   4。 大模块异步加载，例如：Echarts，可以使用 require。ensure，在加载成功后， 在显示对应图表

   5。 小模块适度合并，将一些零散的小模块合并一起加载，速度较快

   6。 可以使用 pefetch 预加载，在分步场景中非常适合

   

   图片优化

   1。 小图使用雪碧图，iconFont， base64 内联

   2。 图片使用懒加载

   3。webp 代替其他格式

   4。 图片一定要压缩

   5。 可以使用的 img 的 srcset，根据不同分辦率显示不同尺寸图片，这样既保证显示效果，又能书省带宽，提高加载速度

   1. 选择合适的图片格式和压缩大图，可从根源上截图大图加载过慢的问题。
   2. 使用雪碧图，iconfont，base64，css 代替图片等可减少图片 http 请求，提高页面加载速度。
   3. 使用 CDN 图片可达到分流的效果，减少服务券压力。
   4. 图片懒加载，预加载，渐进式图片等可不同程度减少白屏时间，提高产品体验。
   
   
   
   css 优化
   
   1。css 写在头部
   
   2。 避免 CSs 表达式
   
   3。 移除空置的 css 规则
   
   4。 避免行内 style 样式
   
   - 减少重排操作，以及减少不必要的重绘
   - 了解哪些属性可以继承而来，避免对这些属性重复编写
   - cssSprite，合成所有icon图片，用宽高加上backgroud-position的背景图方式显现出我们要的icon图，减少了http请求
   - 把小的icon图片转成base64编码
   - CSS3动画或者过渡尽量使用transform和opacity来实现动画，不要使用left和top属性
   
   
   
   js 优化
   
   1。js 写在 body 底部
   
   2。is 用 defer 放在头部，提前加载时间，又不阻塞 dom 解析
   
   3。 script 标签添加 grossorigin，方便错误收集
   
   
   
   渲染染优化
   
   1. 尽量减少 reflow. 和 repaint
   
   涉及到样式,尺寸,节点增减的操作、都会触发 reflow 和 repaint.
   
   1.1 用变量缓存 dom 样式,不要频繁读取
   
   1.2 通计 DocumentFragment 或 innerHTML 批量操作 dom
   
   1.3 dom.隐藏,或复制到内存中,类似 virtual dom,进行修改,完成后再替换回去
   
   1.4 动面元素一定要 absolute,脱离文档流,不影响其他元素,动面不要用 left, top 等操作,要使用 transform 和 opacity,同时开启渲染层(will-change 或 translate3d(0,0,0))
   
   1.5 动画尽量用 requestAnimationFrame,不要用定时器
   
   1.6 移动端硬件加速,触发 GPU 渲染,还是 translate3d(0,0,0)
   
   
   
   
   
   首屏优化
   
   原则：显示快，滚动流畅，懒加载，懒执行，渐进展现
   
   1。 代码分离，将首屏不需要的代码分离出去
   
   2。 服务端渲染或预渲染，加载完 html 直接渲染，减少白屏时间
   
   3。 DNS prefetch，使用 dns-prefetch 减少 dns 查询时间，PC 端城名发散， 移动端域名收敛
   
   4。 减少关键路径 css， 可以将关键的 css。内联，这样可以诚少加载和渲染时间
   
   
   
   打包优化（主要是 webpack 优化）
   
   1。 拆包 exterals dlPlugin
   
   2。 提取公共包 commonChunkPlugin 或 splitChunks
   
   3。 缩小范围各种 loader 配置 include 和 exclude， noParse 跳过文件
   
   4。 开启缓存各种 loader 开启 cache
   
   5。 多线程加速 happypack 或 thead-loader
   
   6。 tree-shaking ES 模块分析，移除死代码
   
   7。 Scope Hoisting ES6 模块分析，将多个模块合并到一个雨数里，减少内存占用，减小体积，提示运行速度
   
   用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。
   
   - 压缩代码:删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的`UglifyJsPlugin`和`ParallelUglifyPlugin`来压缩JS文件， 利用`cssnano`（css-loader?minimize）来压缩css
   
   - 
   
   - 利用CDN加速: 在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于`output`参数和各loader的`publicPath`参数来修改资源路径
   
   - Tree Shaking: 将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数`--optimize-minimize`来实现
   
   - Code Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利用浏览器缓存
   
   - 提取公共第三方库: SplitChunksPlugin插件来进行公共模块抽取,利用浏览器缓存可以长期缓存这些无需频繁变动的公共代码
   
   - 代码切割，使用`code splitting`将代码进行分割，避免将所有代码打包到一个文件，减少响应体积。
   
     按需加载代码，在使用使用的时候加载代码。
   
     压缩代码体积，可以减小代码体积
   
     优化静态资源，使用字体图标、雪碧图、webp格式的图片、svg图标等
   
     使用`Tree Shaking` 删除未被引用的代码
   
     开启`gzip`压缩
   
     静态资源使用`CDN`加载，减少服务器压力
   
   
   
   ## 网络优化
   
   - 使用`HTTP/2`
   - 减少、合并`HTTP`请求，通过合并`CSS、JS`文件、精灵图等方式减少请求数量。
   - 压缩文件， 开启`nginx`，`Gzip`对静态资源压缩
   - 使用`HTTP`缓存，如强缓存、协商缓存
   - 使用`CDN`，将网站资源分布到各地服务器上，减少访问延迟
   
   
   
   webpack 长级存优化
   
   1。发文件使用 chunkhash，不使用 hash
   
   2。cS3。文件使用 contenthash，不使用 chunkhash，不受豆变化影响
   
   3。 提取 vendor，公共库不受业务模块变化影响
   
   4。 内联 webpack runtime 到页面，chunkld 变化不影响 vendor
   
   5。 保证 module ld 稳定，不使用数字作为模块 id，改用文件内容的 hash 值，使用 HashedModuleldsPlugin， 模块的新增或删除，会导致其后面的所有模块 id 重新排序，为避免这个问题
   
   6。 保证 chunkhash 稳定，使用 webpack-chunk-hash，替代 webpack 自己的 hash算法，webpack自己的 hash 算法，对于同一个文件，在不同开发环境下，会计算出不用的hash 值，不能满足跨平台需求，
   
   
   
   2、使用requestAnimationFrame来替代setTimeout和setInterval
   
   　　希望在每一帧刚开始的时候对页面进行更改，目前只有使用 requestAnimationFrame 能够保证这一点。使用 setTimeout 或者 setInterval 来触发更新页面的函数，该函数可能在一帧的中间或者结束的时间点上调用，进而导致该帧后面需要进行的事情没有完成，引发丢帧
   
   　　3、使用IntersectionObserver来实现图片可视区域的懒加载
   
   　　传统的做法中，需要使用scroll事件，并调用getBoundingClientRect方法，来实现可视区域的判断，即使使用了函数节流，也会造成页面回流。使用IntersectionObserver，则没有上述问题
   
   　　4、使用web worker
   
   　　客户端javascript一个基本的特性是单线程：比如，浏览器无法同时运行两个事件处理程序，它也无法在一个事件处理程序运行的时候触发一个计时器。Web Worker是HTML5提供的一个javascript多线程解决方案，可以将一些大计算量的代码交由web Worker运行，从而避免阻塞用户界面，在执行复杂计算和数据处理时，这个API非常有用
   
   　　但是，使用一些新的API的同时，也要注意其浏览器兼容性
   
   

**数据缓存**

不变数据，定期时效可以缓存在cookies或者localstorage中，比如token，用户名等

可以考虑做一个缓存队列，存于内存中（全局对象，vuex)。这样能保证刷新就更新数据，也能一定程度上缓存数据



### 数组对象中有重合的，如何过滤
```javascript
function uniqueObjects(arr) {  
    return arr.filter((obj, index, self) => {  
        return self.findIndex(t => (  
            t.id === obj.id && // 假设每个对象都有一个唯一的id属性  
            t.name === obj.name // 可以根据需要添加更多的比较条件  
        )) === index;  
    });  
}  

// 示例数组  
let array = [  
    { id: 1, name: 'Alice' },  
    { id: 2, name: 'Bob' },  
    { id: 1, name: 'Alice' }, // 重复的对象  
    { id: 3, name: 'Charlie' }  
];  

// 过滤重复对象  
let uniqueArray = uniqueObjects(array);  

console.log(uniqueArray);
```
### 
### 
### 
### 
### 
### 
### 

### JWT
**后端返回的token就是使用jwt**
用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。

客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。

此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization（Usertoken）字段里面。


JWT（JSON Web Token），用来验证客户端身份的一个标识,本质就是一个字符串书写规范，
如下图，作用是用来在用户和服务器之间传递安全可靠的信息
JWTs由三部分组成，用点（.）分隔，具体如下：

- Header（头部）：包含两部分信息，一是声明类型，这里是JWT；二是声明加密的算法，通常直接使用HMAC SHA256、RSA等。
- Payload（负载）：包含声明。声明是关于实体（通常是用户）和其他数据的声明。声明有三种类型：注册的声明、公共的声明和私有的声明。
- Signature（签名）：是对前两部分进行签名，防止数据被篡改。签名需要使用Base64编码后的header和payload数据，通过指定的算法进行签名。

JWT的应用场景包括：

1. 授权：这是使用JWT的最常见场景。一旦用户登录，每个后续请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录（SSO）是JWT的典型用例，因为它的开销很小，并且可以轻松地跨多个域使用。
2. 信息交换：JWT是在各方之间安全地传输信息的好方法。因为JWT可以被签名，例如，用公钥/私钥对，你可以确定发件人是谁。此外，由于签名是使用头和有效负载计算的，你还可以验证内容是否被篡改。
3. 可防护CSRF攻击
4. 适合单点登录


33。了解过JWT吗？

JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之闻安全的把信息作为JSON对象传输信息传输、授权

JWT的认证流程

1。前端把账号密码发送给后端的接口

2。后端核对账号密码成功后，把用户id等其他信息作为]WT 负载，把它和头部分别进行base64编码拼接后签名，形成一个 JWT(token）。

3。前端每日请求时都会把3NT放在HTTP请求头的Authorization字段内

4。后端检查是否存在，如果存在就验证3MT的有效性（签名是否正确，token是否过期）

5。验证通过后后滿使用3MT中包含的用户信息进行其他的操作，并返回对应结果

简洁、包含性、因为Token是JSoN加密的形式保存在客户端，所以MT是跨语言的，原则上是任何web形式都支：


1、用户向服务器发送用户名和密码。

2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。

3、服务器向用户返回一个 session_id，写入用户的 Cookie。

4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。

5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。

### to b 和 to c 
to b  面向企业

to c 面向消费者个人

鲨鱼哥简历项目相关视频学习笔记
https://www.yuque.com/xiaobaoge-lucst/mhfvm6/pmgbq3?
### 对 HTML 语义化的理解
**语义化是指**
根据网页中内容的结构，选择适合的HTML标签进行编写,通俗来讲就是用正确的标签做正确的事情。

语义化的优点如下：

1. 在没有CSS的情况下，页面也能呈现出很好的内容结构、代码结构。
1. 有利于SEO，让搜索引擎爬虫更好的理解网页，从而获取更多的有效信息，提升网页的权重。
1. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。
1. 便于团队开发和维护，语义化的HTML可以让开发者更容易的看明白，从而提高团队的效率和协调能力

- 对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于 SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；
- 对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。

常见的语义化标签：

```html
<header></header>  头部

<nav></nav>  导航栏

<section></section>  区块（有语义化的div）

<main></main>  主要区域

<article></article>  主要内容

<aside></aside>  侧边栏

<footer></footer>  底部
```
### 从浏览器输入 URL 到整个页面渲染成功

<https://juejin.im/post/5a8e242c5188257a6b060000>

- 浏览器的地址栏输入URL并按下回车
- 浏览器查找当前URL是否存在缓存，并比较缓存是否过期
- DNS解析URL中域名对应的服务器主机 IP 地址
- 根据IP建立TCP连接（三次握手）
- 发送HTTP请求
- 服务器响应 http 请求，并返回给浏览器
- 浏览器渲染页面
- 关闭TCP连接（四次挥手）
### 浏览器的渲染流程

1. **解析HTML**：浏览器通过网络请求拿到HTML数据后，会开始解析HTML。在解析过程中，如果遇到CSS（通过link标签引入），浏览器会启动一个单独的CSS预加载器来解析CSS，以避免阻塞HTML的解析。如果遇到JavaScript（通过script标签引入），浏览器会停止解析HTML，直到JS文件下载并执行完成后才继续。

2. **构建DOM树**：解析HTML的过程中，浏览器会根据HTML标签构建DOM（文档对象模型）树。

3. **解析CSS并构建CSSOM树**：同时，浏览器会解析CSS并生成CSSOM（CSS对象模型）树。

4. **构建渲染树**：DOM树和CSSOM树合并成一个 渲染树（Render Tree） 。。这个树只包含需要显示的节点和它们的样式信息。

   渲染树构建完毕之后，元素的位置关系以及需要应用的样式就确定了，这时浏览器会计算出所有元素的大小和绝对位置。

5. **布局**：根据渲染树的结构，计算每个节点在屏幕上的大小、位置等属性，生成布局信息（Layout）。这个过程会发生回流和重绘。

   计算布局采用何种递归算法？**深度优先遍历**

6. **分层**：为了提升渲染效率，浏览器会将渲染树分层。同一层中的节点共享相同的绘制属性，这样只需要对某一层进行绘制操作，而不需要对整个渲染树进行操作。

7. **绘制**：浏览器会为每一层生成绘制指令集，描述每一层应该如何绘制。然后，浏览器将这些绘制信息提交给合成线程。

8. **合成**：合成线程会将每个图层分块，并在光栅化线程池中将图块转换成位图。最后，合成线程会发送绘制图块命令给浏览器进程，浏览器进程根据这些命令生成页面并显示到显示器上。

   

   

   页面何时绘制？

   页面布局完成之后，浏览器会将根据处理出来的结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。

   

- 浏览器回流和重绘：如果页面发生改变，浏览器需要重新计算布局和绘制，这可能会导致性能问题。因此我们应尽量避免频繁的 DOM 操作和调整元素样式，以减少不必要的回流和重绘。
- DOM 解析和 CSS 解析是两个并行的进程，所以这也解释了为什么 CSS 加载不会阻塞 DOM 的解析。
- 然而，由于 Render Tree 是依赖于 DOM Tree 和 CSSOM Tree 的，所以他必须等待到 CSSOM Tree 构建完成，也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后，才能开始渲染。因此，CSS 加载是会阻塞 Dom 的渲染的。
- 由于 js 可能会操作之前的 Dom 节点和 css 样式，因此浏览器会维持 html 中 css 和 js 的顺序。因此，样式表会在后面的 js 执行前先加载执行完毕。所以 css 会阻塞后面 js 的执行。

### css属性开启gpu硬件加速，以及加速步骤有哪些
在传统的渲染过程中，布局和绘制是由CPU来完成的，而在CSS硬件加速下，GPU参与了渲染的处理，从而提高了性能。
1. transform属性：该属性用于应用2D或3D变换效果，如旋转、缩放、平移等。当使用transform属性时，浏览器会将变换任务交给GPU处理，从而实现硬件加速。
2. opacity属性：该属性用于设置元素的不透明度。虽然它主要用于控制透明度，但是一个不为1的值（例如0.99）也可以触发硬件加速。
3. will-change属性：will-change属性可以在元素发生变化之前告诉浏览器哪些属性将要发生变化，从而提前分配 GPU 资源。这有助于避免不必要的性能问题。
4. 使用 backface-visibility 属性： 在动画元素上使用 backface-visibility: hidden; 可以触发 GPU 加速，即使元素不需要进行背面的渲染。
5. filter  滤镜

CSS 硬件加速与重绘和回流的关系在于优化渲染性能：

当应用了硬件加速的 CSS 属性（例如 transform, opacity, will-change 等）时，浏览器可能会将元素绘制到独立的图层（Layer），并使用 GPU 来处理这些属性的变化。这可以减少重绘和回流的影响，从而提高性能。

硬件加速可以使部分样式属性的变化只触发重绘，而不会引发整个页面布局的回流。这有助于减少性能损耗

当设置willchange 之后，相当于我们提前告知了浏览器我们后面可能要做的事情，那么浏览器知道了之后他怎么准备呢？他首先是将你设置 willchange 属性的元素单独列了一层，那么这层独立出来之后，你后面的操作就相当于和别的元素没有任何关联，他单独处理这一块，而且是单独使用 GPU 加速处理，这里GPU 加速可以理解为一个比 CPU渲染能力更强更快的处理方式,但是因为 GPU 能做的事情比较有限，一般都是和显示相关的，所以他的性能更强，因为做的事情比较单一。

### 设备的dpr和图片的清晰度是什么样的关系

**dpr=设备像素/css像素**

设备的DPR越高，其显示的图片清晰度就越高。例如，随着手机屏幕技术的不断进步，DPR逐渐提高，使得现代智能手机能够显示比早期手机更加清晰、细腻的图像。

### 图片是cdn的，要给当前机型最优的图片体验，也要传输的流量是最小的，要做那些事情
为了在给当前机型提供最优的图片体验的同时，确保传输的流量最小，当使用CDN（内容分发网络）来分发图片时，可以考虑以下几个关键因素：

1.  **使用适当的图片格式**：不同的图片格式有不同的压缩效率和特性。例如，JPEG适用于摄影图像，PNG适用于需要透明度的图像，而WebP通常具有更好的压缩效果。根据图片的内容和需求选择合适的格式。
1.  **图片压缩**：使用工具或算法对图片进行压缩，以减小文件大小，同时保持可接受的视觉质量。这可以通过减少颜色深度、移除不必要的元数据或应用更高效的压缩算法来实现。
1.  **自适应分辨率**：根据设备的屏幕尺寸和分辨率提供适当的图片尺寸。不要为低分辨率设备提供高分辨率图片，这样可以节省带宽和存储空间。使用响应式图片技术，如srcset和sizes属性，可以根据设备特性自动选择最佳图片。
1.  **懒加载**：懒加载是一种只加载用户当前可见或即将可见的图片的技术。这可以显著减少初始页面加载时的流量消耗，并提高页面加载速度。
1.  **使用CDN的缓存功能**：CDN通常具有缓存功能，可以缓存经常访问的图片，从而减少对源服务器的请求，降低带宽消耗。确保CDN配置正确，以最大化缓存效率。
1.  **图片CDN优化**：与CDN提供商合作，利用他们的优化功能，如自动格式转换、智能压缩和图片裁剪等。这些功能可以根据设备特性和网络条件自动调整图片，以提供最佳的用户体验。
1.  **使用HTTP/2**：HTTP/2协议通过多路复用和头部压缩等技术，可以更有效地传输多个文件，包括图片。确保CDN和服务器都支持HTTP/2，以进一步提高传输效率。
1.  **分析和监控**：使用分析工具监控图片加载性能和流量消耗，以便识别并优化潜在问题。根据分析结果调整图片优化策略，以持续改进用户体验和降低流量消耗。

综上所述，通过选择合适的图片格式、压缩图片、提供自适应分辨率、使用懒加载、利用CDN缓存和优化功能、使用HTTP/2以及进行分析和监控，可以在提供最优图片体验的同时，确保传输的流量最小。
### js数据类型，如何判断数据类型
- typeof 
- instanceof
- Object.prototype.toString.call()

**typeof会返回一个运算数的基本类型，instanceof 返回的是布尔值**

**typeof可以判断原始数据类型（null 除外），但是无法判断引用数据类型（function 除外）**
能判断的类型有： number，boolean，string，undefined，object，function。
但是不能判断 null，array，object和函数实例（new + 函数），都是返回object

**instanceof 可以准确判断引用数据类型（如null，array等，返回值为布尔值），但是不能正确判断原始数据类型**
所以 instanceof 对对象（array、object、function）判断更加细致清晰。
但是：instanceof 不能判断出基本数据类型（string、number、boolean、undefined、null）的值的类型！

 **共同点：**
    判断类型都各自的不足，都不能完全准确的判断出所有类型！！！
    推荐使用Object.prototype.toString.call()方法：

### 多个接口，失败的接口 retry，最多3次，
在多个接口调用中，当某个接口调用失败时，我们通常希望实现重试机制以确保服务的稳定性和可靠性。要实现这样的机制，你可以使用递归或循环的方式，结合一个计数器来跟踪重试的次数。下面是一个使用JavaScript实现的简单示例，其中每个接口调用失败后最多重试3次：

```javascript
// 假设这是你的接口调用函数，它返回一个Promise  
function callApi(apiUrl) {  
  return new Promise((resolve, reject) => {  
    // 模拟网络请求，这里使用setTimeout模拟异步操作  
    setTimeout(() => {  
      // 随机决定是否成功或失败  
      const success = Math.random() > 0.5;  
      if (success) {  
        resolve(`成功调用接口: ${apiUrl}`);  
      } else {  
        reject(`调用接口失败: ${apiUrl}`);  
      }  
    }, 1000);  
  });  
}  
  
// 重试逻辑封装函数  
function retryApiCall(apiUrl, retryCount = 3, delay = 1000) {  
  return callApi(apiUrl)  
    .catch((error) => {  
      if (retryCount === 0) {  
        // 如果重试次数用完，直接抛出错误  
        throw new Error(`重试失败: ${error}`);  
      } else {  
        // 否则，等待一段时间后重试  
        console.log(`接口调用失败，${retryCount}秒后重试...`);  
        return new Promise((resolve) => {  
          setTimeout(() => {  
            resolve(retryApiCall(apiUrl, retryCount - 1, delay));  
          }, delay);  
        });  
      }  
    });  
}  
  
// 调用多个接口，每个接口都有重试机制  
async function callMultipleApisWithRetry() {  
  try {  
    const apiUrls = ['api1', 'api2', 'api3']; // 假设这是你的接口列表  
    const results = [];  
    for (const apiUrl of apiUrls) {  
      const result = await retryApiCall(apiUrl);  
      results.push(result);  
    }  
    console.log('所有接口调用成功:', results);  
  } catch (error) {  
    console.error('接口调用过程中发生错误:', error);  
  }  
}  
  
// 执行调用多个接口的函数  
callMultipleApisWithRetry();
```
在这个示例中，callApi函数模拟了网络请求，并随机决定成功或失败。retryApiCall函数封装了重试逻辑，它首先尝试调用callApi，如果失败了，它会根据retryCount来决定是否等待一段时间后再重试。如果重试次数用完，它会抛出错误。

callMultipleApisWithRetry函数则负责调用多个接口，并对每个接口调用使用retryApiCall来实现重试逻辑。

请注意，这只是一个简单的示例，实际应用中你可能需要处理更多的细节，比如错误类型的区分、不同接口的重试策略差异、重试间隔的动态调整等。同时，也要考虑性能问题，避免无限制的重试导致资源耗尽或服务器压力过大。

### 谷歌浏览器最多请求多少个接口，是分批还是并发，

①同一域名下，同一GET请求的[并发](https://so.csdn.net/so/search?q=并发&spm=1001.2101.3001.7020)数是1，也就是说上一个请求结束，才会执行下一个请求，否则置入队列等待发送；

②同一域名下，不同GET/POST请求的并发数量是6。当发送的请求数量达到6个，并且都没有得到响应时，后面的请求会置入[队列](https://so.csdn.net/so/search?q=队列&spm=1001.2101.3001.7020)等待发送。

- 在HTTP/1.1中，由于存在连接限制，浏览器通常会限制同一时间针对同一域名的并发请求数。
- 而在HTTP/2中，由于支持多路复用，浏览器可以并发发送更多的请求，而无需等待先前的请求完成。
### http2.0 多路复用是20个请求一起发出去吗
HTTP/2.0 要求必须基于 HTTPS 使用。HTTP/2.0 在开放互联网上只用于 https:// 网址，而 http:// 网址将继续使用 HTTP/1.1。这是为了在开放互联网上增加使用加密技术，以提供强有力的保护去遏制主动攻击。因此，如果你想使用 HTTP/2.0 的特性，就必须使用 HTTPS 协议。

HTTP/2的多路复用并不意味着20个请求会一起被发送出去。多路复用是HTTP/2的一个核心特性，它允许在单个TCP连接上并行发送多个请求和响应，而无需等待前一个请求的响应返回。这大大提高了通信效率和并发处理能力。

然而，具体多少个请求会同时被发送，取决于多种因素，包括网络条件、服务器性能、浏览器或客户端的实现等。浏览器或客户端会根据当前的网络状况、资源使用情况以及请求的优先级等因素，动态地决定何时发送请求以及发送多少请求。

此外，HTTP/2还引入了流的概念，每个请求和响应都被视为一个流，并通过帧的方式进行传输。每个流都有一个唯一的整数ID，以便在多路复用中进行标识和管理。这种设计使得浏览器或客户端可以同时处理多个流，从而实现真正的并行通信。

因此，虽然HTTP/2的多路复用特性允许在单个连接上并行发送多个请求，但具体发送多少个请求并不是固定的，而是根据具体情况动态调整的。

### http1.1 有没有办法突破6个并发的限制
- 将资源分散到不同域名
  浏览器并发连接数限制只是针对同一域名，将资源分散到不同的域名下，即可实现并发数的扩展，例如一个域名是10个，两个域名就是20个并发了。

- 使用http2
###  介绍下 http1.0、http1.1、http2.0 协议
**http1.0**
它的特点是每次请求和响应完毕后都会销毁 TCP 连接，同时规定前一个响应完成后才能发送下一个请求。这样做有两个问题：
在前一个请求响应到达之前才能发送,
**无法复用连接**
每次请求都要创建新的 TCP 连接，完成三次握手和四次挥手，网络利用率低
**队头阻塞**
如果一个请求在响应之前阻塞了，那么后续的请求也会被阻塞。



**http1.1**是 http1.0 的改进版，它做出了以下改进：
**长连接**
http1.1 允许在请求时增加请求头connection:keep-alive，这样便允许后续的客户端请求在一段时间内复用之前的 TCP 连接
**管道化**
基于长连接的基础，支持多个请求同时发送,管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。
**缓存处理**
新增响应头 cache-control，用于实现客户端缓存。
**断点传输**
（断点续传）
在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率




**http2.0**
**二进制格式**
使用二进制格式传输数据，取代了HTTP 1.x中的文本格式。二进制格式的解析效率更高，减少了数据传输的大小，节省了带宽和时间。
**多路复用**
基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，并且不再有队头阻塞问题，也无须遵守响应顺序(可以在一个连接上同时发送多个请求和响应，减少了连接的数量，提高了性能。)
**头部压缩**
http2.0 使用HPACK算法对请求和响应的头部信息进行压缩，减少了数据传输的大小。
**服务器推送**
http2.0 支持服务器主动推送资源给客户端，提高了页面加载速度和性能。

**HTTP/3：**

**基于UDP**：HTTP/3使用基于UDP的传输协议QUIC（Quick UDP Internet Connections），而不是基于TCP的传输协议。
**增强的安全性**：HTTP/3通过TLS 1.3提供了更强的安全性。
**低延迟**：HTTP/3通过使用QUIC协议的连接迁移能力，可以更快地建立和恢复连接，减少了延迟。
**抗丢包**：HTTP/3使用QUIC协议提供了更好的丢包恢复和拥塞控制机制，可以更好地适应不稳定的网络环境。

总的来说，HTTP/1.1是传统的基于文本的协议，HTTP/2引入了二进制协议、多路复用和头部压缩等特性以提高性能，而HTTP/3则进一步改进了传输协议，提供了更低的延迟和更好的抗丢包能力。

缓存机制：
HTTP1.0的缓存处理较为简单，主要依赖“Expires”和“Cache-Control”头字段进行缓存控制。
HTTP1.1则引入了更多的缓存控制机制，如“ETag”和“If-None-Match”等，使得缓存处理更为灵活和高效。
### 为什么 HTTP1.1 不能实现多路复用（腾讯）

HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。

### 简单讲解一下 http2 的多路复用（网易）

在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

### 8. HTTP 1.1 和 HTTP 2.0 的区别
HTTP 1.1 默认连接为持久连接  如果没有要发送的了,客户端最后发送Connection:close首部给服务器
- **二进制协议**：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。
- **多路复用：**HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"【1】的问题。
- **数据流：**HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。
- **头信息压缩：**HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。
- **服务器推送：**HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

**【1】队头堵塞：**

> 队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。

### 9. HTTP和HTTPS协议的区别

HTTP和HTTPS协议的主要区别如下：
- HTTPS在HTTP的基础上用TLS/SSL进行加密
- HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；
- HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；
- 使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；
- HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。

### cdn是第三方还是公司的cdn cdn挂了有做过加急处理吗

<script src="http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js"></script> 
<script>window.jQuery || document.write('<script src="js/vendor/jquery-1.10.2.min.js"><\/script>')</script>

判断Windows.jQuery是否存在 也就是说判断一下这个CDN是不是挂掉了，如果没有挂掉，那么就直接使用，如果挂掉了，那么就要在后面引入自己的本地资源库。这样就可以保证在可以使用cdn的时候使用cdn不可以使用的时候就加载本地的。



通过监听script标签的onerror事件，从候选cdn链接中进行切换

### 如何检测是不是promise
1. Object.prototype.toString.call()   === [object Promise]
2. instanceof     p1 instanceof Promise  // true
3. 通过then
```
  function isPromise(val) {
    return (
      val &&
      typeof val.then === "function" &&
      typeof val.catch === "function"
    );
  }
  console.log(isPromise(p1)); // true
```
### promise的源码
Promise 是一种用于处理异步操作的JavaScript对象，它提供了一种统一的API来处理异步操作的结果，并具有以下特点：

状态不可变。Promise 的状态在创建后一旦改变就不会再变。状态只有两种可能：从pending变为fulfilled（成功）和从pending变为rejected（失败）。一旦状态改变，就会立即返回结果，无法中途取消
链式调用。Promise 提供了then方法，允许用户指定异步操作成功或失败后的回调函数。这些回调函数可以是另一个异步操作，从而实现链式调用，提高代码的可读性和可维护性。
错误处理。Promise 的catch方法用于处理异步操作失败时的错误。
非阻塞性。Promise 内部异步执行其异步操作，不会阻塞主线程，使得程序运行更加流畅
基于发布订阅模式。Promise 的核心原理是基于发布订阅模式，通过两个队列来缓存成功的回调（onResolve）和失败的回调（onReject）
总的来说，Promise 解决了传统异步编程中回调函数导致的回调地狱问题，并提供了一种更加优雅和灵活的方式来处理异步操作的结果和错误。

### async背后做了什么
`async`和`await`是ES2017（也称为ES8）中引入的语法糖，它们使得异步操作（如网络请求、文件读写等）的编写更加简洁和直观。在底层，`async`和`await`是基于Promise实现的，它们提供了一种更加优雅和易于理解的方式来处理异步操作。

当函数被声明为`async`时，它会返回一个Promise对象。这个Promise对象的解析值就是`async`函数返回的（或抛出的）值。这意味着，虽然`async`函数本身是异步的，但它的调用方式看起来就像同步函数一样，这极大地简化了异步代码的编写。

在`async`函数内部，我们可以使用`await`关键字来等待一个Promise对象的完成。`await`表达式会暂停当前`async`函数的执行，直到Promise解析完成，并返回解析后的值。这样，我们可以避免使用复杂的`.then()`链或回调地狱，使得代码更加清晰和易于理解。

在底层，`async`和`await`的实现依赖于JavaScript的运行时环境（如V8引擎）。当遇到`await`表达式时，JavaScript引擎会保存当前的执行上下文（包括局部变量、函数调用栈等），然后将控制权交还给事件循环。当Promise解析完成后，事件循环会调度相应的回调函数来恢复`async`函数的执行，并恢复之前的执行上下文。

此外，`async`函数还提供了更好的错误处理机制。由于`async`函数返回一个Promise对象，我们可以使用`try/catch`语句来捕获和处理可能发生的错误。这使得错误处理更加集中和一致，避免了在多个回调函数之间传递错误状态的复杂性。

总之，`async`和`await`在底层通过Promise和JavaScript的事件循环机制来实现异步操作的处理。它们提供了一种更加直观和易于理解的方式来编写异步代码，使得开发者能够更加高效地处理异步操作。
### async，await的缺点
async和await在异步编程中提供了更直观和简洁的语法，但它们也有一些缺点，具体如下：

1.  **代码可读性**：虽然async和await提高了代码的可读性，但在某些情况下，过度使用或不当使用可能会使代码结构变得复杂，降低可读性。
1.  **错误处理**：虽然async/await可以与try/catch语句结合使用来处理错误，但相比于传统的回调函数或Promise链，错误处理可能变得更加复杂。在多层嵌套的异步操作中，错误传播和捕获可能会变得困难。
1.  **只能用在async函数内部**：await命令只能在async函数内部使用，如果在普通函数中使用，将会报错。这在一定程度上限制了await命令的使用范围。
1.  **无法充分利用并发**：async/await在处理多个异步操作时默认是串行执行的，这意味着一个异步操作完成后才会开始下一个，无法像Promise.all那样利用并发请求来提高代码性能。这对于需要并行处理多个异步任务的情况来说可能是一个缺点。
1.  **浏览器兼容性**：虽然现代浏览器已经广泛支持async/await，但在一些较老的浏览器版本中可能还无法使用。这意味着在使用async/await时，可能需要考虑对老版本浏览器的兼容性问题。

需要注意的是，尽管async和await存在一些缺点，但它们仍然是在许多情况下处理异步操作的优选方式。它们提供了更直观、更易于理解的语法，有助于减少回调地狱和提高代码的可读性和可维护性。在选择是否使用async和await时，需要权衡其优缺点，并根据具体的应用场景和需求做出决策。

### 一句话概述什么是 promise
Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。
promise有三种状态：pending/reslove/reject 。pending就是正在进行中，resolve可以理解为成功，reject可以理解为拒绝
### promise的缺点
1.  promise一旦新建就会立即执行，无法中途取消
2.  当处于pending状态时，无法得知当前处于哪一个状态，是刚刚开始还是刚刚结束
3.  如果不设置回调函数，promise内部的错误就无法反映到外部
4.  promise封装ajax时，由于promise是异步任务，发送请求的三步会被延后到整个脚本同步代码执行完，并且将响应回调函数延迟到现有队列的最后，如果大量使用会大大降低了请求效率。

### 有promise为什么还会出现async 和await
promise 最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。
es6的新语法，async/await就是generator + promise的语法糖
async、await 函数写起来跟同步函数一样，条件是需要接收 Promise 或原始类型的值。异步编程的最终目标是转换成人类最容易理解的形式。
一般情况下 async/await 在错误处理方面，主要使用 try/catch

### 拦截promise的错误抛出，监听那个promise失败
在JavaScript中，你可以使用.catch()方法来拦截一个Promise的错误抛出。当Promise被拒绝（rejected）时，.catch()方法中的回调函数会被调用，并接收拒绝的原因（即错误对象）。
### promise
1. **Promise.all** 返回一个新的 promise,只有所有的 promise 都成功才成功,只要有一个失败了就直接失败
如果都成功，状态成功，返回结果是所有promise的返回值组成的数组。
如果失败，状态失败，返回第一个失败promise的结果值
2. **Promise.allSettled** 它会执行每个promise并返回结果，返回一个数组, 无论其结果是resolve或reject。
3. **Promise.race** 将第一个执行完成的返回，无论其状态是成功还是失败
4. **Promise.any**  它是只要有了一个promise的状态为成功，就返回成功，如果所有promise都是失败，那么其返回失败状态。
5. **then()**：用于处理Promise成功后的回调函数，接受两个参数，第一个是成功回调函数，第二个是失败回调函数。无论成功还是失败，它都会返回一个全新的Promise，因此可以继续进行链式调用。
6. **catch()**：用于处理Promise失败后的回调函数，返回一个新的Promise对象。当Promise对象的状态变为rejected（即异步操作失败）时，catch方法中的回调函数会被调用，并传入异步操作的错误。
7. **finally()**：无论Promise对象的状态是fulfilled还是rejected，finally方法中的回调函数都会被执行。它常用于清理工作，如关闭数据库连接、移除事件监听器等。
8. **Promise.resolve()**：返回一个已经解析（fulfilled）的Promise对象。如果传入的是一个Promise对象，则直接返回该Promise；如果传入的是一个thenable对象（即具有then方法的对象），则先将其转化为Promise再返回。
9. **Promise.reject()**：返回一个已经拒绝（rejected）的Promise对象，并传递一个错误原因。

### css 加快渲染的属性
CSS 渲染速度的优化是一个复杂的过程，涉及到多个方面。以下是一些可以加快 CSS 渲染的属性或策略：

1.  **使用 `transform` 和 `opacity` 替代 `top`, `left` 等进行动画**：  
    使用 `transform` 和 `opacity` 属性进行动画可以触发 GPU 加速，这通常比使用 `top`, `left` 等属性进行动画更快。
1.  **避免使用昂贵的 CSS 属性**：  
    某些 CSS 属性会触发浏览器重排（reflow）或重绘（repaint），这可能会降低渲染速度。例如，`width`, `height`, `margin`, `border`, `font-size` 等属性的变化会触发重排。尽量减少这些属性的使用，特别是在动画和频繁变化的场景中。
1.  **使用 `will-change` 属性**：  
    `will-change` 属性可以让浏览器预先知道哪些属性即将发生变化，从而进行优化。但需要注意的是，过度使用 `will-change` 可能会导致性能下降，因为它会告诉浏览器为这些属性保留额外的资源。
1.  **优化选择器**：  
    避免使用复杂的选择器，特别是嵌套层级过深的选择器。这可以减少浏览器解析和计算样式的时间。
1.  **利用 CSS3 特性**：  
    使用 CSS3 的特性，如阴影（box-shadow）、渐变（gradient）和圆角（border-radius），可以减少对图片的依赖，从而加快渲染速度。
1.  **减少重绘和重排**：  
    尽量合并多个样式更改，以减少浏览器的重绘和重排次数。例如，使用 `requestAnimationFrame` 来批量处理样式更改。
1.  **利用 CSS 压缩和合并**：  
    通过压缩和合并 CSS 文件，可以减少网络传输的开销，从而加快页面加载速度。
1.  **使用 `content-visibility: auto;`** ：  
    这个属性可以告诉浏览器只渲染视口内的内容，对于长列表或大量内容特别有用，可以显著提高滚动性能。
1.  **避免使用 `@import`**：  
    使用 `@import` 会在每个 `@import` 规则的 CSS 文件加载后才渲染页面，这可能导致延迟。尽量直接在 HTML 文件中链接 CSS 文件，或使用多个 `<link>` 标签。
1.  **利用 `contain` 属性**：  
    `contain` 属性可以帮助浏览器将元素的布局、样式和绘制限制在其自身范围内，这有助于减少不必要的渲染工作。

请注意，优化 CSS 渲染是一个综合性的过程，需要根据具体的应用场景和需求来选择合适的策略。同时，随着浏览器技术的不断发展，新的优化方法和技术也会不断涌现。因此，建议定期关注最新的前端技术动态和最佳实践。

### Webpack打包原理

webpack的打包原理：首先它会读取项目中的每个文件，然后根据配置文件中的规则，将这些文件编译成一个或多个bundle文件，最后将这些文件输出到指定的文件夹中。

Webpack的打包原理是基于文件依赖关系的静态分析，通过构建依赖关系图、加载和编译模块、打包输出等步骤，将项目的各种资源转化为可在浏览器中执行的静态资源。

**构建流程**

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。

2. 开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。

3. 确定入口：根据配置中的 entry 找出所有的入口文件。

4. 编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。

5. 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系

6. 输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。

7. 输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。

   ### webpack打包流程

   Webpack的打包流程主要包括以下步骤：

   1.  **读取配置文件**：Webpack首先会读取项目中的webpack.config.js文件，解析其中的配置信息，以便后续的打包过程可以按照这些配置来进行。
   1.  **寻找入口文件**：在解析配置文件之后，Webpack会根据配置中的入口文件来寻找项目的起始点。入口文件是一个JavaScript文件，Webpack会从这个文件开始递归地解析项目中的所有依赖关系。
   1.  **解析依赖模块**：找到入口文件之后，Webpack会递归地解析项目中的所有依赖模块，这包括JavaScript文件、CSS文件、图片文件等。Webpack使用不同的加载器(loader)来解析不同类型的文件。
   1.  **编译模块**：在解析依赖模块之后，Webpack会使用相应的loader来编译这些模块。
   1.  **合并模块**：编译完成之后，Webpack会将所有模块合并成一个或多个包(bundle)。这是通过Webpack根据代码的拓扑结构和配置将模块组织成不同的代码块来完成的。每个代码块可以是一个独立的文件，也可以与其他代码块组合成一个捆绑包。此外，Webpack还使用代码分割(code splitting)技术将应用程序代码拆分成更小的代码块，以便在需要时进行按需加载，从而提高应用程序的性能。

   在整个过程中，Webpack有两种组织模块的依赖方式，即同步和异步。异步依赖将作为分割点，形成一个新的块。在优化了依赖树之后，每一个异步区块都将作为一个文件被打包。

### cdn 原理

CDN（内容分发网络）的原理主要基于内容存储、内容分发和负载均衡三个方面。

 CDN的原理是通过将网站的内容复制到离用户最近的CDN服务器上，使用户访问时更快地获取网站内容。

首先，CDN通过在全球各地建立大量的节点服务器，将网站的静态资源如图片、视频、音频等存储在这些节点服务器上。当用户请求访问网站时，CDN会根据用户的地理位置，将内容从距离用户更近的节点服务器上获取，从而减少数据传输的时间和网络延迟，提高访问速度。

其次，CDN利用智能的路由系统，根据用户的IP地址和网络状况，选择距离用户最近和网络状况最好的节点服务器来提供内容分发服务。这样可以有效地减少数据在传输过程中的延迟和丢包率，提高用户获取内容的效率和质量。

最后，CDN通过负载均衡技术，将用户的请求分发到不同的节点服务器上，从而避免单一服务器负载过重，保证网站的稳定性和可靠性。当某一台服务器出现故障或者负载过高时，CDN会自动将用户的请求转发到其他正常的服务器上，保证用户能够正常访问网站内容。

综上所述，CDN通过在全球范围内部署大量的节点服务器，结合智能路由和负载均衡技术，实现了对用户请求的快速响应和高效分发，从而提升了用户访问网站的体验。

**CDN的主要作用**
CDN 的主要作用是通过就近缓存、加速内容传输和提供全球分发网络，改善用户体验，减轻源服务器负载，并提供更高的网站可用性和保护。

降低成本：通过CDN可以降低带宽和服务器的成本，提高用户体验的同时，降低网站运营成本。

### Es6常用的方法

1.  Let和const关键字
2.  变量的解构赋值
3.  字符串模板
4.  扩展运算符
5.  箭头函数
6.  字符串，数值的扩展
7.  数组，对象的扩展
8.  Symobol
9.  Set和Map
10.  Proxy
11.  Class
12.  Promise
13.  async

### This 指向

- 当函数作为普通函数调用时（非严格模式下），“this”通常指向全局对象（在浏览器中是“window”，在Node.js中是“global”

- 当使用构造函数（如“new”操作符）创建对象时，“this”指向新创建的对象

- 当函数作为对象的方法被调用时，“this”指向该对象。

- 使用call、apply、bind方法调用函数时，“this”被显式绑定到指定的对象

- 在事件处理程序中，“this”指向触发事件的元素。

- 箭头函数不绑定“this”，其“this”值继承自外围上下文

### 闭包

闭包= 内层函数+引用的外层函数变量

打断点，如果出现Closure，说明有闭包，闭包不一定有return，不一定会有内存泄漏

闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。

闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

    function A() {
      let a = 1
      window.B = function () {
          console.log(a)
      }
    }
    A()
    B() // 1

闭包是一个函数加上到创建函数的作用域的连接，闭包“关闭”了函数的自由变量。
**优点：**

* 设计私有方法和变量

* 可以读取函数内部的变量

* 保护函数内部变量的安全，加强了封装性

* 在内存中维持一个变量

  **缺点：**

* 变量会驻留在内存中，造成内存损耗问题。  解决:把闭包的函数设置为null

* 导致内存泄漏【ie】，使用不当会造成额外的内存占用  ==>可说可不说，如果说一定要提到ie

* 可以改变父函数的变量，所以使用时要谨慎

  


### 内存泄露的几种场景
- 全局变量过多。**通常是变量未被定义或者胡乱引用了全局变量**
- 闭包。 未手动解决必包遗留的内存引用。**定义了闭包就要消除闭包带来的副作用**
- 事件监听未被移除
- 缓存。建议所有缓存都设置好过期时间

**内存泄露的解释：程序中己动态分配的堆内存由于某种原因未释放或无法释放。**
- 根据JS的垃圾回收机制，当内存中引用的次数为0的时候内存才会被回收
- 全局执行上下文中的对象被标记为不再使用才会被释放
### 首屏渲染 优化为2s，采用了哪些措施？？？

- 减小入口文件积
- 静态资源本地缓存
- UI框架按需加载
- 图片资源的压缩
- 组件重复打包
- 开启GZip压缩
- 使用SSR

### 浏览器性能指标

FP 白屏（First Paint Time ）： （首次绘制）表示页面绘制第一个像素的时间
FCP 首屏（first contentful paint ）：（首次内容绘制）首屏渲染时间（表示渲染出第一个内容，这里的“内容”可以是文本、图片）
SI (Speed Index)：首屏展现时间
TTI (Time to Interactive)：（可交互时间）页面资源加载成功并能响应用户交互的时间点
TBT (Total Blocking Time)：（总阻塞时间）FCP到TTI之间,主线程被长任务(超过50ms)阻塞的时间之和
LCP (Largest Contentful Paint)：（最大内容绘制）显示最大内容元素所需时间 (衡量网站初次载入速度)
CLS (Cumulative Layout Shift)：累积布局偏移(衡量网页元件视觉稳定性)
FID（First input delay）： 首次输入延迟（用户第一次与页面交互到浏览器实际能够开始处理事件的时间）(衡量网站互动顺畅程度)

### echats底层itwe

ECharts 底层主要依赖于 ZRender，一个使用 JavaScript 实现的跨平台图形库。ECharts 的底层就是使用 ZRender 来进行图形渲染的。

ECharts 底层实现了图形渲染引擎，事件处理系统，动画引擎等，并且提供了一套基于 JavaScript 的图表库，它提供了各种图表的实现，如柱状图、饼图、线图等。

ECharts 底层的工作原理可以概括为以下几个步骤：

1. 初始化：创建一个 ZRender 实例，并且绑定到一个 DOM 元素上。
2. 图形渲染：使用 ZRender 提供的图形 API 来绘制各种图形元素。
3. 交互处理：监听并处理用户的鼠标、触摸等交互事件。
4. 数据处理：处理数据，并且映射到图形元素上。
5. 动画更新：当数据发生变化时，通过 ZRender 提供的动画机制来更新图形，给用户形成动态的视觉效果。

### 封装公共组件

在 Vue 中封装公共组件是一个常见的做法，它可以帮助我们重用代码，提高开发效率，并使代码更易于维护。下面是一个简单的步骤，指导你如何在 Vue 中封装一个公共组件：

1. 创建组件文件

首先，在你的 Vue 项目中创建一个新的 `.vue` 文件来存放你的公共组件。例如，你可以创建一个名为 `MyComponent.vue` 的文件。

2. 编写组件模板

在 `MyComponent.vue` 文件中，编写组件的模板。模板定义了组件的 HTML 结构。

```vue
<template>  
  <div class="my-component">  
    <!-- 组件的内容 -->  
    <slot></slot> <!-- 使用插槽来允许父组件插入内容 -->  
  </div>  
</template>
```

3. 编写组件逻辑

在 `<script>` 标签中，编写组件的逻辑，包括数据、方法、计算属性等。

```vue
<script>  
export default {  
  name: 'MyComponent',  
  props: {  
    // 定义组件接受的属性  
    propName: {  
      type: String,  
      default: ''  
    }  
  },  
  data() {  
    return {  
      // 组件内部的数据  
      internalData: 'Some data'  
    };  
  },  
  methods: {  
    // 组件的方法  
    myMethod() {  
      // ... 方法逻辑  
    }  
  }  
};  
</script>
```

4. 添加组件样式

在 `<style>` 标签中，为组件添加样式。你可以使用普通的 CSS，或者预处理器如 Sass 或 Less。

```vue
<style scoped>  
.my-component {  
  /* 组件的样式 */  
}  
</style>
```

使用 `scoped` 属性可以确保这些样式只应用于当前组件，避免样式冲突。

5. 在其他组件中使用公共组件

现在，你可以在其他 Vue 组件中引入并使用这个公共组件了。

```vue
<template>  
  <div>  
    <my-component :propName="parentData"></my-component>  
  </div>  
</template>  
  
<script>  
import MyComponent from './MyComponent.vue';  
  
export default {  
  components: {  
    MyComponent  
  },  
  data() {  
    return {  
      parentData: 'Data from parent component'  
    };  
  }  
};  
</script>
```

在上面的例子中，我们导入了 `MyComponent` 并在 `components` 选项中注册了它。然后，我们在模板中使用 `<my-component>` 标签来渲染它，并通过 `:propName` 属性传递数据。

6. 测试和调试

确保你的公共组件在各种情况下都能正常工作。你可以编写单元测试来测试组件的功能，并在实际应用中调试它以确保没有错误或问题。

注意事项：

- **命名**：确保你的组件名称遵循 Vue 的命名约定，即使用 PascalCase（大驼峰命名法）。
- **插槽**：使用插槽可以让你的组件更加灵活，允许父组件插入自定义内容。
- **文档**：为你的组件编写清晰的文档，说明其用途、属性、插槽和事件，以便其他开发者能够轻松地使用它。
- **版本控制**：如果你的组件库是一个独立的包，记得使用版本控制来管理不同的版本和更新。

### 动态添加路由，路由如何过滤

在Vue中，动态添加路由通常是通过`router.addRoute`方法实现的。路由过滤可以通过全局的导航守卫来实现。

### 浏览器缓存
**协商缓存和强缓存的区别**
#### （1）强缓存

使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。
**强缓存接口在缓存未过期的情况下，不会向服务器发送请求，因此不会返回状态码**。
**浏览器不会发起请求去服务**，浏览器会直接从本地磁盘（from Disk Cache）或者内存（from memory cache）中读取缓存并返回200状态

强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 **Expires** 属性和 **Cache-Control** 属性。

（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。

（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 **Cache-Control**  属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，

`Cache-Control`可设置的字段：

*   `public`：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；
*   `private`：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；
*   `no-cache`：使用协商缓存；
*   `no-store`：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；
*   `max-age=`：设置缓存的最大有效期，单位为秒；
*   `s-maxage=`：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；
*   `max-stale[=]`：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。

**一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。**

**no-cache和no-store很容易混淆：**

*   no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；
*   no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。

#### （2）协商缓存

如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。

上面已经说到了，命中协商缓存的条件有两个：

*   `max-age=xxx` 过期了
*   `Cache-Control`值为`no-cache`

使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。

协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 **Etag** 和 **Last-Modified** 属性。

（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。

（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。

当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。

**当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。**

**总结：**

强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

### 框架外的性能优化
### 页面的性能优化

1、v-for 正确设置key值
2、封装复用的模块（http请求）、组件（ui库）
3、路由懒加载：component：() => import('./xxx.vue')
4、productionSourceMap: false
5、启用gzip压缩，打包体积更小
6、keep-alive 缓存不活跃组件
7、插件CDN方式引入，减小项目体积
8、图片使用CDN地址，图片懒加载

1. 代码和资源优化

   ：

   - **压缩和合并文件**：压缩CSS和JavaScript文件，减少文件的大小和数量，加快页面加载速度。
   - **图片优化**：使用适当的图像压缩格式，如JPEG、PNG等，并对图像进行适当的缩放和优化，减少其文件大小。
   - **使用异步和延迟加载**：对于非关键资源，如图片、广告和某些脚本，可以使用异步加载或延迟加载技术，等到用户需要访问它们时再加载。

2. 利用缓存

   ：

   - **浏览器缓存**：设置适当的缓存策略，将常用的文件存储在用户的本地缓存中，减少服务器请求和加载时间。
   - **CDN（内容分发网络）**：使用CDN将文件存储在全球各地的服务器上，减少页面加载时间，提高性能。

3. 优化资源加载顺序

   ：

   - **CSS放在顶部**：将CSS文件放在页面顶部可以禁止逐步渲染，节省浏览器加载和重绘页面元素的资源。
   - **JS放在底部**：将JS文件放在页面底部可以防止阻塞解析，提高页面加载速度。

4. 减少HTTP请求

   ：

   - **合并CSS和JavaScript文件**：减少HTTP请求的次数，提高页面的加载速度。
   - **使用CSS Sprites**：将多个小图标合并为一个文件，减少HTTP请求数量。

5. 页面渲染性能优化

   ：

   - **防止阻塞渲染**：使用defer和async属性异步加载不改变DOM和CSS的JS文件。
   - **减少重绘和回流**：尽量减少DOM操作，使用transform进行形变和位移，避免引起回流。

6. 响应时间优化

   ：

   - **减少请求数量**：通过合并、减少或延迟加载非必要资源，降低请求数量，提高响应时间。
   - **优化网络连接**：使用快速、稳定的网络连接，确保用户能够快速获取资源。

7. 其他优化策略

   ：

   - **启用GZIP压缩**：在服务器上压缩网站的页面，减少传输的数据量，提高加载速度。

   - **精简DOM层级**：减少DOM的层级深度，加快DOM树的构建速度，提高页面渲染性能。

   - **利用前端框架和库**：使用现代前端框架和库，它们通常内置了性能优化机制，可以简化优化过程。

     

### function (1,2)可以改成function (1)(2)

```
// 原始函数，接受两个参数  
function add(a, b) {  
  return a + b;  
}  
  
// 柯里化版本的函数  
function curryAdd(a) {  
  return function(b) {  
    return a + b;  
  };  
}  
  
// 使用柯里化版本的函数  
const addFive = curryAdd(2); // 返回一个新的函数，该函数等待第二个参数  
const result = addFive(3); // 调用返回的函数并传入第二个参数，得到结果 8  
const addResult = add(2,3) // 5
const res = curryAdd(2)(3)  // 5
console.log(result); // 输出：5
```
### diff算法
https://blog.csdn.net/Wr2138/article/details/128268759
![image](https://img-blog.csdnimg.cn/fffabe6892db4cd4ba36420133daeee0.png)
数据改变 ----触发--> setter---触发--->Dep.notify ---通知订阅者---> patch(oldvnode, newvnode)

之后判断新旧两个节点是否为同类标签，如果不是同类标签就直接替换；如果是同类标签的话，进一步执行patchVnode()方法，在这个方法内部，也是需要先判断一下新旧虚拟节点是否相同，如果相等，就直接return；如果不相等就需要分情况来比对，比对的原则就是以新虚拟节点的结果为准，分为以下几种情况：

oldvnode和newvnode都有文本节点---执行--->用新的文本节点替换旧文本节点
oldvnode没有子节点，newvnode有子节点---执行--->添加新的子节点
oldvnode有子节点，newvnode没有子节点---执行--->删除旧的子节点
oldvnode和newvnode都有子节点---执行--->updateChildren()方法
updateChildren
同级比对 --- 减少比对次数，可以最大化的提高比对性能
![image](https://img-blog.csdnimg.cn/b2d4fb99fe9640b3ae49fcd4d05f224e.png)
首尾指针法

        ①依次比对，当比较成功后退出当前比较
    
        ②渲染结构以newVnode为准
    
        ③每次比较成功之后start点和end点向中间靠拢
    
        ④当新旧节点中有一个start点跑到end点右侧时终止比较
    
        ⑤如果都匹配不到，则旧虚拟DOM key只去比对新虚拟DOM的key值，如果key相同则复用，并移动到新虚拟DOM的位置

比对顺序

        首先，旧虚拟节点的start和新虚拟节点的start做比对，如果没有比对成功，就用旧虚拟节点的start和新虚拟节点的end做比对
         如果依旧没有比对成功，就用旧虚拟节点的end和新虚拟节点的start做比对，如果依旧没有比对成功，旧虚拟节点的end会和新虚拟节点的end做比对
    
          比对原则就是依照以上顺序依次比较
    
        当比对成功，就退出当前比对，渲染结果会以新虚拟节点的结果为准
    
        每次比对成功后，比对成功的start会向右侧移动，end会向左侧移动。在移动的过程中，当start点跑到end点右侧的时候就终止比较

### MutationObserver 
MutationObserver用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动都会触发MutationObserver事件。
但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。
Mutation Observer 有以下特点：

它等待所有脚本任务完成后，才会运行（即异步触发方式）。
它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。
它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动
使用场景: 
1. 计算首屏加载时间
2. 编辑器自动保存
3. Div 水印
在上面的文本编辑器例子中，除了在文本框修改会触发监听回调，打开控制台在文档树中直接修改也能触发回调：

这就给我们提供了一种保护 DOM 结构的思路：例如在页面中打水印的场景，只需要用最简单的 div 覆盖最上层实现，然后监听这些水印节点，无论水印被何种方式删除，都可以监听到然后把它还原回去~

同理，如果页面中插入第三方广告，也可以用来检查广告是否被屏蔽等。
### CSS会不会阻塞页面渲染和解析
DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。
然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。
由于js可能会操作之前的Dom节点和css样式，所以js要等css和dom渲染就位之后才能工作。所以css会阻塞后面js的执行。

1. css加载不会阻塞DOM树的解析
2. css加载会阻塞DOM树的渲染
3. css加载会阻塞后面js语句的执行

### DOMContentLoaded 和 load
都是用来标识DOM文档加载完成的事件

1.加载时机:
window.onload页面所有DOM加载完成后触发;
DOMContentLoaded在DOM树构建完成后触发,不会等待其他资源的一个加载,只要DOM加载完成,构建完成就执行

2.事件是否能多次触发: window.onload不行! DOMContentLoaded可以

3.兼容性:window.onload在IE8一下不支持:DOMContentLoaded在IE9以上才支持

### 前端工程化

前端工程化是指将前端开发中的设计、开发、测试和部署等环节进行标准化和自动化，以提高开发效率和代码质量，并降低维护成本。

具体而言，前端工程化包括以下方面：

1.  模块化：使用模块化思想可以将复杂的代码拆分成小的可重用的模块，并且使得不同模块之间的依赖关系更加清晰。
1.  自动化构建：通过使用构建工具（如 Gulp、Webpack、Rollup 等），可以自动化地完成代码编译、压缩、打包、转换、优化等任务，从而提高开发效率。
1.  自动化测试：通过使用自动化测试框架和工具（如 Jest、Mocha、Chai、Selenium 等），可以自动化地完成单元测试、集成测试、UI 测试等任务，从而提高代码质量并减少故障。
1.  自动化部署：通过使用自动化部署工具（如 Jenkins、Travis CI、GitLab CI/CD 等），可以自动化地完成代码上传、服务器部署、数据库更新等任务，从而减少手动操作产生的错误和漏洞。
1.  规范化管理：通过使用代码规范（如 ESLint、Stylelint、Prettier 等）和版本控制系统（如 Git），可以规范开发流程和代码风格，提高代码可读性和可维护性。

前端工程化是将前端开发中的设计、开发、测试和部署等环节进行标准化和自动化，以提高开发效率和代码质量，并降低维护成本。

它是一种现代化的开发方式，适用于各种大小项目的开发，并且可以在不断变化的技术环境中保持竞争力。

前端工程化是指将前端开发过程中的各种工具、流程和最佳实践结合起来，以提高前端代码质量、效率和可维护性的一种开发方式。它包括代码管理、自动化构建、模块化开发、包管理、持续集成/部署等方面。通过前端工程化，可以帮助开发者更加高效地进行前端开发，并提供更好的协作环境和代码质量保障。


### 判断一个对象为空对象的几种方法
```
方法1：将对象转换成字符串（toString(),String(),JSON.stringift()），再判断是否等于“{}”
方法2:Object.keys()方法，返回对象的属性名组成的一个数组，若长度为0，则为空对象
方法3：Object.getOwnPropertyNames方法获取对象的属性名，存到数组中，若长度为0，则为空对象
方法4：jQuery中的isEmptyObject()方法,(其原理是利用for in的方式来判断)
方法5:for in循环
let result=function(obj){
    for(let key in obj){
        return false;//若不为空，可遍历，返回false
    }
    return true;
}
console.log(result(obj));//返回true
```
### Web Worker 报错会影响主线程吗
Web Workers 是一种在Web应用中运行后台任务的机制，它们允许在浏览器的主线程之外运行脚本，从而不会阻塞用户界面的渲染。这种机制使得复杂的计算或网络操作可以在后台执行，而不会影响到主线程的性能。

当 Web Worker 报错时，它主要影响的是该 Worker 自身的执行，并不会直接影响到主线程。Worker 中的错误不会导致主线程崩溃或报错，但可能会影响 Worker 内的任务执行。具体来说：

错误处理：在 Worker 脚本中，你应该使用 try...catch 语句或 window.onerror 来捕获和处理错误。如果你没有这样做，那么错误可能会导致 Worker 停止执行，但不会影响到主线程。

消息传递：主线程和 Worker 之间通过消息传递进行通信。如果 Worker 报错并停止执行，那么它可能无法发送预期的消息回主线程，但主线程不会因此崩溃。

资源清理：如果 Worker 报错并停止，那么你应该确保清理与之相关的所有资源，例如通过调用 Worker.terminate() 方法来手动终止 Worker。

总的来说，Web Worker 报错不会直接影响主线程的执行，但可能会影响 Worker 自身的任务执行和与主线程之间的通信。因此，在使用 Web Workers 时，建议对 Worker 脚本进行充分的错误处理，并确保在不再需要时正确清理相关资源。

### ssr
为什么客户端渲染首屏渲染慢？
所谓的首屏，是我们在浏览器中输入一个地址后，打开的第一个页面，就是首屏。

我们在浏览器的地址栏中输入了地址，向服务器发送请求，服务器返回的是一个空白HTML,没有具体的数据内容，只有js脚本，这时浏览器还会向服务器发送请求获取数据。

而服务端渲染，是在服务端获取数据，然后构建好对应的模板，生成HTML返回到客户端，这样客户端无需再向服务器发送请求。这样通过对比可以看到，客户端渲染需要多次向服务器发送请求，所以导致渲染慢。

服务器端渲染的优缺点
优点：
（1）更好的seo：抓取工具可以直接查看完全渲染的页面。现在比较常用的交互是页面初始展示 loading 菊花图，然后通过异步请求获取内容，但是但抓取工具并不会等待异步完成后再行抓取页面内容。
（2）首屏渲染快，内容到达更快：不用等待所有的 js 都完成下载并执行，所以用户会更快速地看到完整渲染的页面。

缺点：
（1）服务器渲染应用程序，需要处于 Node.js server 运行环境
（2）开发成本比较高

###  git rebase 和 merge 的区别

merge会形成一个四边形，产生一个新的commit，就是一次新的提交，把develop分之带过来了
rebase抛开commidid的变化，就相当于develop从没出现过一样，按顺序在master新提交一遍；

`rebase `会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交

### git reset --soft 和 git reset --hard

用于更改当前分支的提交历史

`git reset --soft` 保留了工作目录中的文件和未提交的更改，

`git reset --hard` 则会丢弃所有未提交的更改，并且重置工作目录中的文件以匹配指定的提交版本

### git reset 和 reverse

- git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit
- git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容
- git reverse，也是回退，但是不是重置commit，而是多出一条commit 

### git stash

保存当前工作进度，会把暂存区和工作区的改动保存起来

git stash/git stash pop 搭配使用

### git stash list

显示保存进度的列表。也就意味着，`git stash`命令可以多次执行，当多次使用`git stash`命令后，栈里会充满未提交的代码

### git stash pop

`git stash pop` 从栈中读取最近一次保存的内容，也就是栈顶的`stash`会恢复到工作区

### 逆地址解析
使用腾讯地图来实现的
https://blog.csdn.net/shenchengyv/article/details/134215622
### 继承
#### 1. class继承

```javascript
// 1. class+extends继承
class Parent{
  constructor(){
      this.age = 18
  }
}

class Child extends Parent{
  constructor(){
    // 必须要写，否则报错，super作为函数调用时表示父类的构造函数，
    // 但super内部的this指向的是子类
      super()
      this.name = '张三'
  }
}
let o1 = new Child(22)
console.log(o1) // child {name:'张三',age:18}
```
#### 2. 原型链继承

```javascript
  /* 　重点：让子实例的原型等于父类的实例。
　　　　优点：1. 实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）
　　　　缺点：1. 新实例无法向父类构造函数传参。
　　　　　　　2. 继承单一。
　　　　　　　3. 所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！） */
  function Parent() {
    this.age = 20;
    this.hobbyList = ["唱歌", "跳舞"];
  }

  function Child() {
    this.name = "张三";
  }

  //继承父类
  Child.prototype = new Parent();
  let c1 = new Child();
  let c2 = new Child();
  // 所有新实例都会共享父类实例的属性  如果属性是引用数据类型，修改了一个实例的属性，其他实例的属性都发生变化，如果属性是基本数据类型的话，就不会有这个变化
  c1.name = "李四";
  c1.hobbyList.push("打游戏");
  console.log(c1, c1.hobbyList); // Child {name: '李四'} (3) ['唱歌', '跳舞', '打游戏']
  console.log(c2, c2.hobbyList); //  Child {name: '张三'} (3) ['唱歌', '跳舞', '打游戏'] */
```
#### 3. 构造函数继承
```javascript
  /*   重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））
　　　　优点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
　　　　　　　2、解决了原型链继承缺点1、2、3。
　　　　　　　3、可以继承多个构造函数属性（call多个）。
　　　　　　　4、在子实例中可向父实例传参。
            5、解决了原型链实现继承的不能传参的问题和父类的原型共享的问题。 
　　　　缺点：1、只能继承父类构造函数的属性。
　　　　　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）
　　　　　　　3、每个新实例都有父类构造函数的副本，臃肿。
            4、子类无法访问父类原型中的方法和属性。（这个原型链继承可以解决) */
  function Parent() {
    this.age = 22;
    this.hobbyList = ['唱歌']
  }
  Parent.prototype.sex = "男";

  function Child() {
    this.name = "张三";
    // 创建子类实例时调用Parent构造函数，于是Child的每个实例都会将Parent中的属性复制一份
    // this指向Child
    Parent.call(this);
  }
  //  无法继承父类原型的属性。
  let o1 = new Child(); 
  let o2 = new Child();

  console.log(o1);  // child {age: 22, name: "张三"} hobbyList: ['唱歌']
  console.log(o2);  // child {age: 22, name: "张三"} hobbyList: ['唱歌']
```
#### 4. 组合继承（原型链+构造函数）

```javascript
  /*  重点：结合了两种模式的优点,使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。传参和复用
　　　　优点：1、可以继承父类原型上的属性，可以传参，可复用。
　　　　　　　2、每个新实例引入的构造函数属性是私有的。
　　　　缺点：调用了两次父类构造函数, 生成了两份实例（耗内存），子类的构造函数会代替原型上的那个父类构造函数。
     */
  function Parent() {
    this.age = 11;
  }

  Parent.prototype.sex = "男";

  function Child() {
    // 借用构造函数模式
    Parent.call(this);
    this.name = "张三";
  }

  // 原型链继承
  Child.prototype = new Parent();
  Child.prototype.constructor = Child;
  let c1 = new Child();
  console.log(c1);   // age: 11 name: "张三"
```
#### 5. 原型式继承

```javascript
  /*  
  重点： 用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。
        object.create()就是这个原理。
  特点： 类似于复制一个对象，用函数来包装。
  缺点： 1、所有实例都会继承原型上的属性。 
        2、无法实现复用。（新实例属性都是后面添加的） 
  */

// es5之后
var parent = {
  name: "Parent",
  sayHello: function () {
    console.log("Hello");
  },
};

var child = Object.create(parent);
console.log(child.name); // Parent
child.sayHello(); // Hello
```
#### 6. 寄生式继承

```javascript
 /*    
  重点：就是给原型式继承外面套了个壳子。
  优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。
  缺点：没用到原型，无法复用。
    */

function createChild(parent) {
  const child = Object.create(parent);
  child.name = "Child";
  child.sayHello = function () {
    console.log(`Hello, I'm ${this.name}`);
  };
  return child;
}

const parent = {
  name: "Parent",
};

const child = createChild(parent);
child.sayHello(); // 输出 "Hello, I'm Child"
```
#### 7. 寄生组合继承（最优）

```javascript
 function Parent() {
    this.age = 100;
  }

  function Child() {
    // 借用构造函数模式
    Parent.call(this);
    this.name = "张三";
  }
  // 原型链继承
  Child.prototype = Object.create(Parent.prototype);
  Child.prototype.constructor = Child;
  let o4 = new Child();
  console.log(o4, o4.name, o4.age); // Child {age: 100, name: '张三'} '张三' 100

```
### 移动端适配方案
**1. px2vw (推荐) (vw 方案)**
安装 postcss-px2vp
```
npm install postcss-px2vp
```
```
根目录新建 postcss.configs.js配置：
module.exports = {
  plugins: {
    "postcss-px2vp": {
      viewportWidth(rule) { //1. 如果设计稿宽度是750px，使用 Vant
        const file = rule.source?.input.file;
        return file?.includes("vant") ? 375 : 750; //设计图尺寸
      },
      // viewportwidth:750,  // 2. 如果设计稿宽度是 750px + 不使用 Vant 
      // viewportwidth:375,  // 3.如果设计莉宽度是 375px + 无论是否使用 Vant
      propList: ['*','!font*','!line-height','!letter-spacing'],//转换的属性列表，此处包括所有属性。不包括字体，行高等
    },
}
```
说明：

- 使用postcss-px2vp，而不是 postcss-px-to-viewport，是因为后者：

​		不支持设置动态 viewportwidth，就无法同时支持宽度是 750px 的设计稿+ Vant 

​		不支持 PostCSs 8

- Vant 的设计稿宽度是 375px，但我们的设计稿宽度大多是 750px 

- 字体不转换，保持 px 单位

**2. postcss-pxtorem (不推荐)**
安装 amfe-flexible 和 postcss-pxtorem

```
npm install amfe-flexible postcss-pxtorem --save
```
```
入口文件 main.js 中引入
import 'amfe-flexible';

根目录新建 postcss.configs.js配置：
module.exports = {
  plugins: {
      "postcss-pxtorem": {
        rootValue({file}) {  //1. 如果设计稿宽度是750px，使用 Vant
          return file?.includes("vant") !== -1 ? 37.5 : 75; //设计图尺寸
        },
        // rootValue:75,  // 2. 如果设计稿宽度是 750px + 不使用 Vant 
        // rootValue:37.5,  // 3.如果设计莉宽度是 375px + 无论是否使用 Vant
        propList: ['*','!font*','!line-height','!letter-spacing'],//转换的属性列表，此处包括所有属性。不包括字体，行高等
      },
}

关于单位换算你可能会感觉理解起来有点难,做的东西多了,自然而然就懂了,正所谓熟能生巧,哪有天生百步传扬的本领,殊不知千百箭换来的那一箭,下方rootvalue 就先理解为设计稿的尺寸 / 10 就行了,为了么除以10呢,因为flexble里面默认分为10等份,你也可以自行修改平分的份数,这时候的rootvalu就是设计稿 / 你设置的份数
```
说明:

1. amfe-flexible 设置 rem 的基准值（即 <html style=" font-size: XXXpx">

2. postcss-pxtorem 是一个 PostCSS 插件,将 px 转为 rem


第二种rem更适合PC端，设计稿尺寸通常1920*1080

### h5和小程序页面布局如何适配的 750的设计稿
让所有元素根据用户手机屏幕的宽度等比例的自动的放大缩小
#### h5
 postcss-px2vp
#### 小程序如何做自适应 （torem 使用单位）
小程序可以直接用 uni-app 或小程序自带的单位 rpx 即可。这时候，uni-app 或原生小程序框架内部，会自动进行处理的。750px 的设计稿下，1px = 1rpx 即可。
### 跨域的解决方案
https://juejin.cn/post/6844903767226351623#heading-15
1. cors
2. nginx反向代理
3. Proxy（vue中使用）
4. postMessage
5. websocket
6. Node中间件代理(两次跨域)
7. jsonp
8. location.hash + iframe
9. document.domain + iframe
10. window.name + iframe


jsonp: 原理就是通过添加一个<script>标签，向服务器请求JSON数据
postMessage: 页面和新打开的窗口间数据传递，多窗口之间数据传递，页面与嵌套的 iframe 之间数据传递
cors: 服务器指定了 Access-Control-Allow-Credentials: true
document.domain + iframe：适用主域名相同，子域名不同的跨域场景
window.name + iframe：利用name值最长可以 2M ，并用不同页面或不同域名加载后依然存在的特性
location.hash + iframe：适用通过 C 页面来实现 A 页面与 B 页面通信的场景

403 Forbidden
服务器拒绝执行此请求。CORS跨域失败会发送这个状态码。
### nginx反向代理配置
<!-- nginx代理 响应头，post会多一个请求，预请求 -->
```javascript
// proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;
    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
```

### 大文件上传
**分段上传：**
将一个大文件切割成多个小文件，分别上传，然后在服务端组合。这种方式可以提高上传速度和可靠性，但需要额外的前后端开发和维护工作。
**Websocket 上传：**
使用WebSocket协议进行文件上传。WebSocket提供了全双工通信，可以实时传输数据，适合处理大文件上传。通过WebSocket，可以将文件拆分成多个分片，并逐个发送到服务器端。
通过WebSocket协议实现实时的双向数据传输，适用于大文件或大量数据的实时传输，但需要特殊的服务器支持。
**通过第三方服务上传：**
比如使用云存储服务（如七牛、阿里云OSS等）进行文件上传，即使是大文件也可以快速上传，同时也可以享受到云存储服务的稳定性和安全性。

针对不同的场景和业务需求，可以选择适合自己的上传方案。


### canvas中某个元素的按钮绑定一个点击的事件
1. 利用定位覆盖
思路：canvas标签的父亲固定定位，canvas标签绝对定位且canvas标签撑满父盒子，canvas标签的父盒子还有子元素，这些子元素绝对定位就可以覆盖在canvas画布上。
当canvas 上需要实现类似的点击事件，就可以使用 canvas 标签父盒子里面的子元素，定位覆盖点击区域。实现canvas 画布上类似的DOM操作。
2. 全局监听局部响应
思路：现在只有一个 canvas 标签了。要进行 DOM 操作添加事件只能给画布这个 DOM 节点添加事件，那索性我们就给DOM节点添加事件。然后通过鼠标的 event 来计算鼠标的距离画布左上角的水平和垂直距离。现在我们只需要判断画布上的色块的坐标能包住鼠标的坐标，条件成立时，添加对应的事件，这时候你想怎么玩画布上的内容都行。

### 图片懒加载是在小程序还是pc端用的
小程序图片懒加载
1. 使用 wx:if 条件渲染
1. 这种方案是使用微信小程序提供的 IntersectionObserver 组件，来监听图片是否出现在可视区域内，从而实现图片的懒加载。

pc端
1. vue-lazyload

### 什么是插件
插件可以扩展程序的功能，增加新的特性，或者改善程序的性能。通过安装和使用插件，用户可以根据自己的需求定制程序，满足个性化的使用要求。

### 图片懒加载
（1）使用element-ui 的<el-image v-for="url in urls" :key="url" :src="url" lazy></el-iamge>可通过lazy开启懒加载功能，当图片滚动到可视范围内才会加载。
（2）使用vue-lazyLoad插件实现
（3）使用IntersectionObserver Api监听某些节点是否出现在可视区域内。
（4）offsetTop（图像距离顶部的高度）-scrollTop(页面被卷去的高度)<=window.innerHeight（可视区高度）才加载
（5）获得页面中某个元素的上边相对浏览器视窗的位置getBoundingClientRect().top<=window.innerHeight（可视区高度）才加载
### 伪类和伪元素有哪些，什么情况下使用
伪类主要用于选择元素的特定状态或行为，并为其添加样式
伪元素则用于创建并操作元素的特定部分，为这些部分添加样式
伪类 :link、:visited、:active、:hover、:focus、:first-child、:last-child
伪元素: :before和, ::after,::first-letter, ::first-line, ::first-letter
权重:  伪类是10, 伪元素是1

### 重绘和回流
浏览器采用流式布局模型（Flow Based Layout） 浏览器会把 HTML 解析成 DOM，把 CSS 解析成 CSSOM，DOM 和 CSSOM 合并就 产生了渲染树（Render Tree）。 有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。
**浏览器解析渲染机制**
-   解析HTML，生成DOM树，解析CSS，生成CSSOM树
-   将DOM树和CSSOM树结合，生成渲染树(Render Tree)
-   Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
-   Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
-   Display:将像素发送给GPU，展示在页面上
**重绘是指元素样式发生变化，但是并不影响页面布局的情况下，浏览器重新绘制该元素。例如修改颜色、背景图片等属性时，会引起重绘操作。**
**回流是指元素的布局或几何属性发生变化时，浏览器需要重新计算元素的位置和大小，然后对整个页面进行重新布局的操作。例如添加、删除、移动、改变元素尺寸、改变窗口大小等情况下，会引起回流操作**
回流（Reflow）：当页面布局和几何属性改变时，就需要回流。这通常发生在以下情况：
添加或删除可见的DOM元素。
元素位置或尺寸改变，如边距、填充、边框、宽度和高度内容改变。
页面渲染初始化。
浏览器窗口尺寸改变，如resize事件发生时。
使用某些CSS属性，如float、absolute position等。
回流一定会触发重绘，因为回流需要重新计算页面的布局，之后浏览器会重新绘制受影响的部分到屏幕上。

重绘（Repaint）：当元素的属性或样式发生变化，但不影响布局时，会发生重绘。
例如，改变元素的背景颜色或文字颜色。文本方向的修改，阴影的修改

如何避免重绘和回流
避免频繁访问DOM属性：由于访问DOM属性会导致页面的重新计算和重新绘制，因此应该尽量避免频繁访问DOM属性，可以将其缓存到变量中减少访问次数。

减少重排和重绘：尽量避免修改多个元素的样式或者同时对多个元素进行DOM操作，将其合并成一个操作，从而减少重排和重绘的次数。

1.  **使用CSS3动画或transform**：这些属性通常在GPU层面处理，不会引起回流，性能更好。(使用transform属性可以改变元素的位置和尺寸，而不会引起页面的重新布局，从而减少回流操作。)
1.  **避免频繁读取布局信息**：在JavaScript中，频繁读取布局信息（如`offsetTop`、`offsetLeft`等）会强制浏览器进行回流。尽量避免这类操作，或者将其缓存起来以减少回流次数。
1.  **使用文档片段（DocumentFragment）进行DOM操作**：先创建一个文档片段，在其上进行DOM操作，最后再将文档片段一次性添加到文档中，这样可以减少频繁的回流。
1.  **使用position:absolute或fixed进行动画**：相对于其他元素使用`position:absolute`或`fixed`进行定位，这样不会影响其他元素的布局。
1.  **缓存计算结果**：如果需要多次读取某个计算结果，可以将结果缓存起来，避免重复计算，减少回流次数。
1.  **集中改变样式className**：一次性改变多个样式属性，而不是逐一改变，以减少回流次数。
1.  **避免使用table布局**：table布局在渲染时可能会导致多次回流。

每次回流都会伴随重绘，因为回流改变了布局，而重绘则是根据新的布局绘制元素。但由于回流和重绘都是资源密集型操作，因此为了提高性能，浏览器通常会尝试优化这些过程，例如通过队列化修改并批量执行来减少回流和重绘的次数。

### 节流和防抖，使用场景
**防抖函数的应用场景：**
- 表单验证

- 搜索框搜索输入

  **节流函数的适⽤场景：** 

- 拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动 

- 缩放场景：监控浏览器resize 

- 滚动scroll事件

```javascript
// 防抖 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时，重新出发定时器。
/* 
   应用场景
      登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖
      调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖
       文本编辑器实时保存，当无任何更改操作一秒后进行保存
  */
function debounce(fun, delay) {
  let timer;
  return function () {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fun.apply(this, arguments);
    }, delay);
  };
}
```

**节流**

```javascript
// 节流  规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效
 /* 
     应用场景
        鼠标连续不断地触发某事件（如点击），单位时间内只触发一次；
        监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断。例如：懒加载；
        浏览器播放事件，每个一秒计算一次进度信息等
   */
function throttle(fun, delay) {
  let timer;
  return function () {
    if (!timer) {
      timer = setTimeout(() => {
        fun.apply(this, arguments);
        timer = null;
      }, delay);
    }
  };
}

 function throttle(func, delay) {
    // 上一次执行的时间
    let pre = 0;
    return function () {
      // 现在的时间
      let now = new Date();
      //   如果现在的时间减去上次执行的时间大于delay就执行函数
      if (now - pre > delay) {
        func.apply(this, arguments);
        // 把当前时间赋值给上一次的执行时间
        pre = now;
      }
    };
  }
```
### js和ts的区别
https://juejin.cn/post/7174236227573874718

TypeScript 是 JavaScript 的类型的超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等

TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法
TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译
TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js
在编写 TypeScript 的文件的时候就会自动编译成 js 文件

### **TypeScript 中 type 和 interface 的区别?**

> 相同点： 
>
> 1. 都可以描述 '对象' 或者 '函数' 
> 2. 都允许拓展(extends)
>
> 不同点： 
>
> 1. type 可以声明基本类型，联合类型，元组
> 2.  type 可以使用 typeof 获取实例的类型进行赋值
> 3. 多个相同的 interface 声明可以自动合并
>
> 使用 interface 描述‘数据结构’，使用 type 描述‘类型关系’

### 主要用ts哪些特性
typescript的特性主要有如下：

类型批注和编译时类型检查 ：在编译时批注变量类型
类型推断：ts中没有批注变量类型会自动推断变量的类型
类型擦除：在编译过程中批注的内容和接口会在运行时利用工具擦除
接口：ts中用接口来定义对象类型
枚举：用于取值被限定在一定范围内的场景
Mixin：可以接受任意类型的值
泛型编程：写代码时使用一些以后才指定的类型
名字空间：名字只在该区域内有效，其他区域可重复使用该名字而不冲突
元组：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组
...

### 什么场景下使用
### ts泛型
泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型 在typescript中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性

当我们定义一个变量不确定类型的时候有两种解决方式：

使用any
使用any定义时存在的问题：虽然 以 知道传入值的类型但是无法获取函数返回值的类型；另外也失去了ts类型保护的优势
使用泛型
泛型指的是在定义函数/接口/类型时，不预先指定具体的类型，而是在使用的时候在指定类型限制的一种特性。

泛型变量
对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：
```javascript
T（Type）：表示一个 TypeScript 类型
K（Key）：表示对象中的键类型
V（Value）：表示对象中的值类型
E（Element）：表示元素类型
```
二、泛型用法
2.1 在函数中使用泛型
```javascript
function test <T> (arg:T):T{
  console.log(arg);
  return arg;
}
test<number>(111);// 返回值是number类型的 111
test<string | boolean>('hahaha')//返回值是string类型的 hahaha
test<string | boolean>(true);//返回值是布尔类型的 true
```

使用方式类似于函数传参，传什么数据类型，T就表示什么数据类型， 使用表示，T也可以换成任意字符串。

2.2 在接口中使用泛型
```javascript
// 注意，这里写法是定义的方法哦
interface Search {
  <T,Y>(name:T,age:Y):T
}

let fn:Search = function <T, Y>(name: T, id:Y):T {
  console.log(name, id)
  return name;
}
fn('li',11);//编译器会自动识别传入的参数，将传入的参数的类型认为是泛型指定的类型
```
2.3 在类中使用泛型
```javascript
class Animal<T> {
 name:T;
 constructor(name: T){
  this.name = name;
 }
 action<T>(say:T) {
   console.log(say)
 }
}
let cat = new Animal('cat');
cat.action('mimi')
```
三、泛型约束
3.1使用接口约束泛型 
```javascript
interface Person {
  name:string;
  age:number;
}
function student<T extends Person>(arg:T):T {
  return arg;
}

student({name:'lili'});//类型 "{ name: string; }" 中缺少属性 "age"，但类型 "Person" 中需要该属性
student({ name: "lili" , age:'11'});//不能将类型“string”分配给类型“number”
student({ name: "lili" , age:11});
```
3.2 数组泛型
```javascript
let arr:Array<number> =[1,2,3] === let arr:number[]=[1,2,3]
```
### 栈和队列
栈：先进后出（First In Last Out ）FILO (你可以把栈想象成一个竖直堆叠的盘子，新盘子被放在顶部，要取盘子时只能从顶部取。)
队列：先进先出（First In First Out）FIFO (你可以把队列想象成排队等候的人，先来的人先服务，后来的人后服务。)  
 **栈的实际运用场景：**
- 撤销操作：许多软件应用程序在实现撤销功能时会使用栈。每当用户执行一个操作时，比如添加、删除或修改，相关信息将被推入栈中。当用户选择撤销时，程序将从栈中弹出最近的操作并还原到上一个状态。
- 后退/前进功能：网页浏览器中的后退和前进按钮也可以使用栈来实现。在浏览网页时，每次访问一个新页面时，当前页面的信息将被推入栈中。当用户点击后退按钮时，程序将从栈中弹出最近的访问页面，并显示上一个页面。
- 递归算法：递归算法也使用栈来实现。在递归函数中，每次递归调用时，函数的当前状态（包括参数和局部变量）会被推入栈中。当递归函数结束时，栈会弹出并还原上一个状态。
- 函数调用：在JavaScript等前端语言中，函数调用也使用了栈的数据结构。每次函数被调用时，它的参数和局部变量等信息会被推入调用栈中，当函数执行完毕返回时，这些信息会从栈中弹出。

**队列的实际运用场景：**

- 动画和过渡效果：在前端动画和过渡效果的实现中，队列也扮演着重要角色。例如，当多个CSS动画或JavaScript动画需要连续或同时执行时，可以使用队列来管理这些动画的执行顺序和状态。
- 广度优先搜索算法：在图论和算法领域，广度优先搜索算法使用队列来实现。该算法通过逐层遍历图中的节点，并使用队列来存储待访问的节点，从而实现对整个图的搜索。
- 批处理任务处理：在系统设计中，队列经常用于处理批处理任务。任务被排队进入队列，通过一个或多个处理器逐个处理。
- 异步处理：在前端开发中，异步处理是非常常见的需求。例如，在用户注册后需要发送注册邮件和注册短信，这种场景下可以使用队列来实现异步处理。将发送邮件和发送短信的任务放入队列中，然后由一个单独的线程或进程来消费这些任务，从而实现异步执行。
### 按钮权限 
通过公用的hasPermission方法配合v-if、v-show指令，或者disbaled属性控制按钮的是否渲染或禁用
### 自定义指令如何实现代码
定义指令permission
```javascript
export default {
  inserted(el, binding, vnode) {
    const { value } = binding
    const roles = store.getters && store.getters.roles

    if (value && value instanceof Array && value.length > 0) {
      const permissionRoles = value

      const hasPermission = roles.some(role => {
        return permissionRoles.includes(role)
      })

      if (!hasPermission) {
        el.parentNode && el.parentNode.removeChild(el)
      }
    } else {
      throw new Error(`need roles! Like v-permission="['admin','editor']"`)
    }
  }
}
```
### 切换node版本
```
nvm 
nvm install <version> # 安装指定版本
nvm use <version>    # 切换到指定版本
```
### 事件冒泡，使用场景，多层的话每层都有吗，什么用途，阻止冒泡，

事件捕获先于事件冒泡触发。在事件捕获阶段，事件从DOM树的根节点向下传播到目标元素；在事件冒泡阶段，事件从目标元素向上冒泡到根节点。

事件冒泡是JavaScript中的一种事件传播机制，当一个元素上发生某个事件时，这个事件会按照从内到外的顺序逐级传递给父元素，直到传递到文档根元素（通常是window对象），这种传播的过程和气泡在水中冒升的过程类似，因此被称为事件冒泡

事件冒泡的过程是：事件首先在触发它的最具体的元素（目标元素）上发生，然后逐级向上冒泡到更一般的元素，直到达到DOM树的根节点。当事件冒泡时，父级元素的事件处理程序会在子级元素的事件处理程序之前被触发

事件冒泡的一个常见应用场景是事件委托（event delegation），通过事件委托，我们可以将事件处理程序绑定到父级元素，而不是直接绑定到每个子元素，从而减少了事件处理程序的数量，提高了性能和代码的可维护性

事件冒泡会从当前触发的事件目标一级一级往上传递，依次触发，直到document为止。
事件捕获会从document开始触发，一级一级往下传递，依次触发，直到真正事件目标为止。


需要注意的是，在某些应用场景，事件冒泡可能会产生一些问题，就是我们不需要触发的事件，由于冒泡的原因，也会运行。所以在这个时候要取消事件冒泡。

如何阻止事件冒泡
*   普通浏览器使用：event.stopPropagation()
*   IE浏览器使用：event.cancelBubble = true;
```
我们使用addEventListener的时候，主要用来实现事件的绑定监听的

存在三个参数 target.addEventListener(type, listener, useCapture);

type: 表示监听事件类型的字符串。类似于click,mouseover...
listener: 用来监听处理的函数方法
useCapture: 默认是false,事件冒泡,可以设置为true为事件捕获
```

### 事件委托，使用场景，
事件冒泡的一个常见应用场景是事件委托

应用场景：
现在有一个ul，ul里又有100个li，我想给这100个li都绑定一个点击事件，我们一般可以通过for循环来绑定，但是要是有1000个li呢？ 为了提高效率和速度，所以我们这时可以采用事件委托，只给ul绑定一个事件，根据事件冒泡的规则，只要你点了ul里的每一个li，都会触发ul的绑定事件，我们在ul绑定事件的函数里通过一些判断，就可以给这100li都触发点击事件了

### DOM和BOM的理解，有哪些常用的属性
DOM 是表示 HTML 和 XML 文档的标准的对象模型。它将文档中的每个组件（如元素、属性、文本等）都看作是一个对象，开发者可以使用 JavaScript 来操作这些对象，从而动态地改变页面的内容、结构和样式。
DOM 以树状结构组织文档的内容，其中树的根节点是 document 对象，它代表整个文档。document 对象有各种方法和属性，可以用来访问和修改文档的内容和结构。

BOM 是表示浏览器窗口及其各个组件的对象模型。它提供了一组对象，用于访问和控制浏览器窗口及其各个部分，如地址栏、历史记录等。
BOM 的核心对象是 window 对象，它表示浏览器窗口，并且是 JavaScript 中的全局对象。window 对象提供了许多属性和方法，用于控制浏览器窗口的各个方面，如页面导航、定时器、对话框等。
BOM 还提供了其他一些对象，如 navigator（提供浏览器相关信息）、location（提供当前文档的 URL 信息）、history（提供浏览器历史记录）、screen（提供屏幕信息）等。

总的来说，DOM 是用于访问和操作网页文档的对象模型，而 BOM 是用于控制浏览器窗口及其各个组件的对象模型。在 JavaScript 编程中，开发者通常会同时使用 DOM 和 BOM 来完成各种任务，如操作网页元素、导航控制、事件处理等。

### DOM
DOM（Document Object Model）文档对象模型
DOM的api不属于JS语言的本身，而是浏览器实现了api，并且浏览器给了开发者用js来操作dom的权力

### BOM
BOM（Browser Object Model）浏览器对象模型

BOM提供的API都放到全局对象window中
DOM也属于BOM的一部分。属于document
1.  **window对象**：
    -   window对象是BOM的顶层对象，代表浏览器窗口，其他BOM对象都是window对象的子对象。
    -   window对象提供了许多属性和方法，如innerWidth和innerHeight分别表示浏览器窗口的宽度和高度。
    -   window对象下还有两个特殊的属性，window.name和window.top。
    -   window对象还包含了一系列对话框方法，如alert()、prompt()和confirm()，用于弹出警告框、输入框和带有确定取消按钮的对话框。
1.  **document对象**：
    -   document对象是DOM（Document Object Model）的核心，而非BOM的直接属性，但经常与BOM交互。
    -   它包含了整个HTML文档的结构，可以通过它访问和修改页面中的元素。
1.  **location对象**：
    -   location对象代表了当前浏览器窗口的URL地址栏。
    -   它包含了许多属性，如href（表示完整的URL）、protocol（表示协议）、hostname（表示主机名）、port（表示端口号）等。
    -   location对象也提供了一些方法，如reload()用于重新加载页面，replace()用于替换当前历史记录项。
1.  **navigator对象**：
    -   navigator对象包含了关于浏览器的信息。
    -   通过它可以获取浏览器的名称、版本、内核等。
    -   常用的属性有appName（浏览器名称）、appVersion（浏览器版本信息）、userAgent（用户代理字符串）等。
1.  **screen对象**：
    -   screen对象包含了关于客户端屏幕的信息。
    -   常用的属性有width和height（屏幕的宽度和高度）、availWidth和availHeight（可用工作区的宽度和高度）等。
1.  **history对象**：
    -   history对象主要用于记录浏览器的访问记录。
    -   它提供了前进和后退页面的功能，通过go()方法可以实现页面的跳转。
    -   常用的属性有length（历史记录列表中的URL数量）。

这些只是BOM中常用对象的一部分属性，实际上BOM的功能非常丰富，可以根据具体需求进行深入学习和使用。同时，由于不同浏览器对BOM的支持可能存在差异，因此在实际开发中需要注意兼容性问题。

### flex常用的属性
**容器的属性**

> **flex-direction**    主轴的方向(row | row-reverse | column | column-reverse)
> **flex-wrap**           是否换行(nowrap | wrap | wrap-reverse)
> **flex-flow**              flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap
> **justify-content**    主轴上的对齐方式（flex-start | flex-end | center | space-between | space-around）
> **align-items**           在交叉轴上如何对齐（flex-start | flex-end | center | baseline | stretch）
> **align-content**      多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用（flex-start | flex-end | center | space-between | space-around | stretch），比justify-content属性多了一个stretch属性

baseline: 项目的第一行文字的基线对齐。
stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

**项目的属性**

> **order**  项目的排列顺序。数值越小，排列越靠前，**默认为0**
> **flex-grow**  定义项目的放大比例，**默认为0**，即如果存在剩余空间，也不放大。
> **flex-shrink**  属性定义了项目的缩小比例，**默认为1**，即如果空间不足，该项目将缩小。
> **flex-basis**  定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为**auto**，即项目的本来大小
> **flex**  是flex-grow, flex-shrink 和 flex-basis的简写，**默认值为0 1 auto**。后两个属性可选，该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。**flex：1 是flex: 1 1 0%的简写，flex子项将根据可用空间进行增长或缩小，并且其基本大小为0。**
> 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。
> **align-self**  允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch（auto | flex-start | flex-end | center | baseline | stretch），属性取6个值，除了auto，比align-items属性多了一个auto属性

如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
负值对该属性无效。
### 使用translate来变位置，而不是使用定位，优点是什么 比定位的优点
-   **动画和过渡效果**：使用 CSS 的 `translate` 可以创建更平滑的动画和过渡效果。浏览器会为元素创建一个GPU图层。这意味着元素的位移操作只在它自己的图层上进行，不会影响整个页面的布局。这种GPU加速可以进一步提高动画的流畅性和性能
-   **性能优化**：当使用绝对定位来移动元素时，浏览器会触发重排（reflow）和重绘（repaint）。重排是浏览器为了重新计算页面的布局而进行的操作，而重绘则是浏览器将新的布局绘制到屏幕上的过程。这两个过程都会消耗一定的计算资源。然而，translate是transform的一个值，改变transform或opacity不会触发浏览器重新布局或重绘，只会触发复合（composite）。这意味着使用translate进行位置变化时，浏览器不需要重新计算页面的布局或绘制整个页面，从而提高了性能。
-   **布局流的不干扰**：使用 `translate` 移动元素时，原来元素的空间仍然保留，元素的移动不会影响到其他元素的布局。而改变 `position` 属性会直接影响到元素在文档流中的位置，可能会导致周围元素的重新布局。
-   **更灵活的控制**：`translate` 可以提供更为精细的位置控制，特别是在创建复杂的动画和效果时。
### 前端跨页面通信的方法，如何实现的
1.  **Broadcast Channel**：
    -   Broadcast Channel 提供了一种广播式的通信方式，允许在同一来源的不同文档（如不同的窗口、选项卡、框架或 iframe）之间进行通信。
    -   创建一个标识唯一的频道，例如 `const bc = new BroadcastChannel('myChannel');`。
    -   通过 `bc.onmessage` 监听频道上的消息，并在接收到消息时执行相应的操作。
    -   使用 `bc.postMessage(data)` 向频道发送消息。
1.  **Window.postMessage**：
    -   `postMessage` 是一种 HTML5 引入的 API，用于在不同窗口或框架之间安全地传递信息。
    -   在发送消息的窗口或框架中，使用 `targetWindow.postMessage(message, targetOrigin)` 方法发送消息。其中 `targetWindow` 是目标窗口的引用，`message` 是要发送的数据，`targetOrigin` 指定了哪些源可以接收消息。
    -   在接收消息的窗口或框架中，通过监听 `message` 事件来接收和处理消息。
1.  **localStorage + 事件监听**：
    -   利用 `localStorage` 存储数据，并通过监听 `storage` 事件来实现跨页面通信。
    -   当一个页面修改 `localStorage` 时，会触发 `storage` 事件，其他页面可以通过监听这个事件来获取到修改的数据。

1.  **Service Worker**：
    -   Service Worker 作为消息处理中心，可以在后台运行并处理来自不同页面的消息。
    -   通过 Service Worker，可以实现跨页面的数据共享和通信。
    -   通常结合 Broadcast Channel 或 `postMessage` API 来实现跨页面通信。
1.  **WebSocket**：
    -   WebSocket 提供了一种全双工的通信方式，允许在客户端和服务器之间实时传递数据。
    -   通过建立 WebSocket 连接，不同页面可以共享同一个连接，从而实现跨页面通信。
    -   这种方法适用于需要实时通信的场景，如聊天应用或实时更新数据的页面。
1.  **SharedArrayBuffer 和 Atomics**：
    -   `SharedArrayBuffer` 和 `Atomics` 提供了一种在多个 Web Worker 之间共享内存的方式。
    -   通过这种方式，不同的页面或 Worker 可以访问和操作同一块内存区域，实现跨页面通信。
1.  **第三方库和框架**：
    -   一些第三方库和框架也提供了跨页面通信的解决方案，如 Redux、MobX 等状态管理库，以及 PubSub、EventEmitter 等事件发布/订阅库。
### requestAnimationFrame的理解
`requestAnimationFrame` 是一个浏览器提供的 API，用于在浏览器的下一次重绘之前执行动画或执行某些操作。这个 API 提供了一个高性能的方式来进行动画和渲染，因为它确保了你的代码会在浏览器的下一次绘制循环中执行，从而实现了平滑的动画效果。
**基本用法**
`requestAnimationFrame` 接受一个回调函数作为参数，这个回调函数会在下一次浏览器重绘之前被调用。
**优点**
1.  **性能优化**：`requestAnimationFrame` 的回调在浏览器的下一次绘制之前被调用，因此它与浏览器的绘制循环同步。这确保了动画的平滑性，并避免了不必要的绘制和重排。
1.  **节能**：当页面不可见或标签页被最小化时，`requestAnimationFrame` 会暂停调用，这有助于节省电池寿命。
1.  **简单使用**：不需要手动设置定时器或使用复杂的时间计算来保持动画的平滑性。

**注意事项**
1.  **清除动画**：如果你不再需要动画，应该清除 `requestAnimationFrame` 的回调，以防止内存泄漏。你可以通过调用 `cancelAnimationFrame` 方法来实现这一点。
2.  **兼容性**：虽然现代浏览器都支持 `requestAnimationFrame`，但在一些旧版本的浏览器中可能不受支持。你可以使用 polyfill 来确保在所有浏览器中的兼容性。

**实际应用**
`requestAnimationFrame` 在创建平滑的动画、游戏、实时渲染等方面非常有用。它允许你与浏览器的绘制循环同步，从而实现高质量的视觉效果。
总之，`requestAnimationFrame` 是一个强大的工具，可以帮助你创建高性能的动画和渲染效果。

与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。
### 箭头函数的理解
箭头函数是一种特殊的函数表达式，其语法用箭头（=>）代替了传统的function关键字来定义函数。箭头函数具有简洁的语法，使得编写函数更加快速和简单，同时提高了代码的可读性和可维护性。
箭头函数的基本语法是：
```
javascript复制代码
	const functionName = (parameters) => { functionBody };
```
其中，`functionName` 是函数的名称（可选），`parameters` 是函数的参数列表，`functionBody` 是函数体。如果函数体只有一条语句，可以省略大括号，并且如果这个函数是一个表达式（即它返回一个值），那么这个返回值可以隐式地返回，无需使用 `return` 关键字。

箭头函数有几个重要的特性：
1.  **没有自己的`this`**：箭头函数不绑定自己的`this`，它捕获其所在上下文的`this`值，作为自己的`this`值。因此，在箭头函数内部，`this`的值将和定义时所在的作用域保持一致。
1.  **没有`arguments`对象**：由于箭头函数没有自己的`this`值，因此它们也没有`arguments`对象。如果需要访问传入参数的数量或列表，可以使用剩余参数（`...args`）语法。
1.  **不能用作构造函数**：箭头函数没有`prototype`属性，因此不能被用作构造函数。
1.  **不支持`yield`**：箭头函数不能用作Generator函数，因为它们不能使用`yield`关键字。
箭头函数的使用场景很广泛，特别是在需要保持`this`上下文不变或者需要简洁语法的地方。然而，在需要动态绑定`this`或者需要`arguments`对象的情况下，传统的函数表达式或方法可能更为合适。

### Nginx反向代理
Nginx 实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。

使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。

我们只需要配置nginx，在一个服务器上配置多个前缀来转发http/https请求到多个真实的服务器即可。这样，这个服务器上所有url都是相同的域 名、协议和端口。因此，对于浏览器来说，这些url都是同源的，没有跨域限制。而实际上，这些url实际上由物理服务器提供服务。这些服务器内的 javascript可以跨域调用所有这些服务器上的url。

### 引用类型和基本类型的区别
原始类型与引用类型三种情况下的对比：
1. 赋值：原始类型赋【值】；引|用类型赋【引用】
2. 比较：原始类型比较的是值是否相等；引用类型比较的是【引用】是否指向同一对象。
3. 函数传参：原始类型作为参数，函数内的操作不影响实参的值。引用类型作为参数，函数内的操作会影响实参的值。
### 引用类型使用中的问题
1. 修改了一个变量，发现另一个变量也随之变化。
2. 对比两个变量，明明是相同的，但比较的结果就是false。

### 什么是深拷贝、什么是浅拷贝？
浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝 的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个 地址，就会影响到另一个对象。
深拷贝： 会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即 发生深拷贝。 深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。

### JSON.parse(JSON.stringify(obj))深浅拷贝的缺陷
JSON.parse(JSON.stringify(obj)) 这种方法常被用来实现对象的深拷贝，但它实际上存在一些缺陷和限制：
建议使用专门的深拷贝库（如 lodash 的 _.cloneDeep 方法能正常实现深copy）或者手动实现深拷贝函数，

1. 如果obj里有函数，undefined，Symbol, 则序列化的结果会把函数,undefined,Symbol丢失。
2. 日期(Date)对象转换为字符串
3. 如果对象中存在循环引用的情况也无法正确实现深拷贝。
4. 如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null。
5. 如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象{}。
6. JSON.stringify()只能序列化对象的可枚举的自有属性。如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor。
```javascript
function Person (name) {
    this.name = 20
}

const haluo = new Person('haluo')

let a = {
    data0: '1',
    date1: [new Date('20203-04-28'), new Date('2023-05-05')],
    data2: new RegExp('w+'),
    data3: new Error('10'),
    data4: undefined,
    data5: function () {
        console.log(1)
    },
    data6: NaN,
    data7: haluo
}

let b = JSON.parse(JSON.stringify(a))

{   data0: "1",
    data2: {},
    data3: {},
    data6: null,
    data7: {name:20},
    date1: ['+020203-04-27T16:00:00.000Z', '2023-05-05T00:00:00.000Z']
}
```
### var，let的区别
var，let声明都会挂载到那?
在全局作用域下声明变量时，var和let的行为是有所不同的。

在全局作用域下，使用var声明的变量会挂载到全局对象上。在浏览器环境中，这个全局对象通常是window。这意味着你可以通过window对象来访问这些变量。

```
var a = 1;  
console.log(window.a); // 输出 1
```

此外，var声明的变量还存在变量提升的现象，即变量会被提升至其所在作用域的最顶部，尽管它的赋值不会提升。


与var不同，let声明的变量在全局作用域下不会挂载到window对象上。let声明的变量具有块级作用域，但它的作用域在全局下实际上就是全局作用域本身（因为它不属于任何函数或代码块内部）。尽管如此，你仍然不能通过window对象来访问let声明的全局变量。例如：

```
let b = 1;  
console.log(window.b); // 输出 undefined
```

此外，let不存在变量提升的问题，它遵循暂时性死区，即在声明之前的代码块中引用该变量会导致引用错误

总结来说，在全局作用域下，var声明的变量会挂载到window对象上，而let声明的变量则不会。因此，使用let声明的全局变量更加封装和安全，因为它们不会被意外地通过window对象访问到。在现代JavaScript开发中，推荐使用let和const来声明变量，以避免var的一些潜在问题。

### for循环和forEach哪个性能好
forEach不能跳出循环，可以使用try...catch, new Error
在js中有break return continue 对函数进行中断或跳出循环的操作

在遍历数组时，通常认为forEach循环会比for循环更快，因为它直接使用了迭代器的方式，无需通过索引来访问元素，从而减少了索引计算和访问元素的时间。然而，具体执行速度还会受到编程语言的实现、代码逻辑和数据结构大小等因素的影响。

对于链表数据结构，for循环的性能可能会低于foreach。因为for循环每次获取链表节点都要从头开始查找，而foreach是采用迭代方式，查找节点只需遍历一次，节省了很多时间。

此外，在JVM预热的情况下，对于大数据量的处理，stream遍历可能在性能上表现更优，尤其是在数据量达到10万或更多时。而parallelStream异步并行处理在数据量非常大时（如100万）性能最高。然而，这些结论是基于特定环境和数据量的测试结果，并不适用于所有情况。

* for 更快
* forEach 每次都要创建一个函数来调用，而 for 不会创建函数

总的来说，for循环和forEach循环在性能上的差异并不是绝对的，而是取决于具体的使用场景和数据结构。在实际编程中，应根据代码的特点和性能要求来选择适合的循环方式。如果只需要简单地遍历数组或集合，并且不关心索引或需要破坏原始数据结构，那么foreach循环可能是一个更好的选择。如果需要对索引进行复杂的操作或需要控制循环的终止条件，那么for循环可能更合适。
### webpack loader比较坑的地方
Webpack loader在前端开发中扮演着重要的角色，它们能够转换和处理源代码中的不同类型文件，使得Webpack能够打包非JavaScript文件。然而，使用loader时也可能会遇到一些“坑”，这些通常是由于配置不当或理解不足导致的。以下是一些Webpack loader可能比较坑的地方：

1.  **配置复杂性**：Webpack的配置文件通常是一个大而繁琐的JavaScript对象，需要手动定义入口点、输出路径、加载器、插件等。对于新手来说，理解并掌握各种配置选项可能会比较困难，例如入口点、输出路径、加载器的使用顺序以及可能的转换和处理选项等。配置错误可能导致打包失败或输出不符合预期。
1.  **版本兼容性问题**：不同的loader版本可能与Webpack的某些版本不兼容，这可能导致在升级Webpack或loader时出现错误。因此，需要仔细检查并更新相关依赖项以确保它们之间的兼容性。
1.  **文件匹配规则**：loader的配置通常涉及文件匹配规则，这些规则决定了哪些文件会被特定的loader处理。如果规则设置不当，可能会导致某些文件被错误地处理或遗漏。
1.  **性能问题**：在某些情况下，使用过多的loader或复杂的loader配置可能会导致打包速度变慢。这可能是因为每个loader都需要对文件进行转换和处理，增加了额外的计算负担。
1.  **调试困难**：当loader出现问题时，调试可能会比较困难。因为loader是在Webpack内部运行的，所以需要熟悉Webpack的工作原理和loader的实现方式才能有效地进行调试。

为了避免这些问题，建议在使用loader时遵循以下最佳实践：
-   仔细阅读loader的文档，了解其配置选项和使用方法。
-   尽量使用稳定且经过社区验证的loader版本。
-   在升级Webpack或loader时，先备份现有的配置文件，并仔细测试新的配置以确保没有问题。
-   简化配置，避免不必要的loader和复杂的配置选项。
-   使用Webpack的内置功能或插件来优化打包性能。

请注意，随着Webpack和loader的不断发展，这些问题可能会逐渐得到解决或变得不那么突出。因此，建议保持对最新动态的关注，以便及时了解和应对可能出现的问题。
### 常用的loader和plugin

image-loader：加载并且压缩图片文件
json-loader 加载 JSON 文件（默认包含）
vue-loader：加载 Vue.js 单文件组件
cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里
ts-loader: 将 TypeScript 转换成 JavaScript
sass-loader：将SCSS/SASS代码转换成CSS
css-loader：加载 CSS，支持模块化、压缩、文件导入等特性
style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS
postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀
file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)
url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)
babel-loader：把 ES6 转换成 ES5

raw-loader：加载文件原始内容（utf-8）
source-map-loader：加载额外的 Source Map 文件，以方便断点调试
svg-inline-loader：将压缩后的 SVG 内容注入代码中
handlebars-loader: 将 Handlebars 模版编译成函数并返回
awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader
eslint-loader：通过 ESLint 检查 JavaScript 代码
tslint-loader：通过 TSLint检查 TypeScript 代码
mocha-loader：加载 Mocha 测试用例的代码
coverjs-loader：计算测试的覆盖率
i18n-loader: 国际化





webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)
html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader)
clean-webpack-plugin: 目录清理
mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)
ignore-plugin：忽略部分文件

define-plugin：定义环境变量 (Webpack4 之后指定 mode 会自动配置)
web-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用
uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前)
terser-webpack-plugin: 支持压缩 ES6 (Webpack4)
webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度
serviceworker-webpack-plugin：为网页应用增加离线缓存功能
ModuleConcatenationPlugin: 开启 Scope Hoisting
speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)

### h5和移动端为啥有1px的问题
在移动端H5开发中解决1px问题的方法可以有以下几种：
使用伪类元素：通过在需要显示细线的元素上使用::after或::before伪类元素，并设置其高度为1px，然后再使用transform: scaleY(0.5)进行缩放，即可实现真实的1像素线条效果。

使用viewport单位：可以使用vw单位代替px单位来定义元素的宽度或边框大小。例如，将元素的边框设置为1vw，可以使其在不同设备上以相对于视口宽度的比例进行自适应。

使用缩放技术：通过JavaScript或CSS的transform属性，将页面整体缩放到0.5倍或更小的比例，可以使得原本的1像素线条在高像素密度设备上以真实的1像素显示。
————————————————

### 数组常用的方法
```javascript
// 改变数组的方法
push, pop, shift, unshift, splice, sort, reverse, copyWithin, fill

// 不改变数组的方法
concat, slice, indexOf, includes, toString, join, toLocaleString, flat, flatMap

//遍历数组的方法
for...of, forEach, every, some, filter, find, findIndex, findLast, findLastIndex, map, reduce, reduceRight, keys, values, entries
```
splice方法的参数
向数组中指定位置添加/删除元素
语法：array.splice(start\[, deleteCount\[, item1\[, item2\[, ...]]]])
指定修改的开始位置, 删除的元素个数, 添加数组的元素
### 字符串常用的方法
charAt(index)。返回指定索引位置的字符，如果索引超出了字符串的长度，则返回空字符串。
slice(start, end)。返回字符串的指定片段，如果start或end为负数，则表示从字符串末尾倒数开始截取。
substring(start, end)。与slice类似，也返回字符串的指定片段。
substr(start, length)。返回从指定位置开始，长度为length的字符串片段。
indexOf(substring, startIndex)。返回子字符串在字符串中第一次出现的索引，如果没有找到，则返回-1。
lastIndexOf(substring, endIndex)。返回子字符串在字符串中最后一次出现的索引，如果没有匹配到，则返回-1。
search(substring)。返回与查找内容匹配的第一个字符串的位置。
concat(str1, str2)。用于将多个字符串拼接起来，返回拼接后的新字符串。
split(separator, limit)。将一个字符串分割为子字符串，并将结果作为字符串数组返回。
toLowerCase()。将字符串中的字母转换成小写。
charCodeAt(index)。返回指定索引位置的字符的Unicode编码。
fromCharCode(code1, code2, ...)。使用指定的字符编码返回对应的字符。

###  一个字符几个字节来表示
一个字符用几个字节来表示，这取决于使用的字符编码方式。

在ASCII码编码方案中，一个英文字符占用一个字节，而一个中文字符无法用ASCII码表示。
在Unicode编码方案中，无论是英文字符还是中文字符，都占用两个字节的空间，从而解决了ASCII码位数不够无法表示汉字的问题。
在UTF-8编码方案中，英文字符通常占用一个字节，而汉字则通常需要三个字节来表示，只有生僻字才会被编码成4~6个字节。UTF-8编码的出现是为了解决Unicode表示字母时的存储空间浪费问题，它可以根据数字的大小编码成不同长度的字节序列，从而更加节约存储空间。
此外，还有其他的编码方式，如GBK和GB2312，它们也用于表示中文字符。在GBK编码中，一个字符占两个字节。而在GB2312编码中，每一个字符存储时需占用2个字节。
UTF-16编码中一个英文字母字符或一个汉字字符在都需要2个字节来存储。然而，对于Unicode扩展区中的一些汉字，它们可能需要4个字节来存储。

因此，不能简单地说一个字符在UTF-16编码中占用固定数量的字节，而是需要根据具体的字符来确定。但大多数情况下，一个字符在UTF-16编码中占用2个字节。

因此，一个字符用几个字节来表示并不是固定的，它取决于具体的字符编码方式以及所表示的字符类型。
### 字符串 concat方法和+连接有什么区别
concat只能接收字符串，而+可以是字符串或者数字及其他基本类型数据。

+左右可以为null，concat会报空指针

如果拼接空字符串concat会稍快，但是可以忽略不计，如果拼接更多的字符串建议使用StringBuider。

+编译后就是使用了StringBuider来拼接，所以使用一行+就会创建一个StringBuilder,多个+就会创建多个，所以建议使用StringBuider


concat只能接收字符串参数，而+操作符在会对其他数据类型做toString()转换再运算
当a为null时，a.concat(b)会抛出NullPointerException异常，但a += b会使用a的默认值进行运算
concat速度更快，但在多字符串拼接时+操作符更方便


举个项目中用到的例子

### mixin
mixin（混入），提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。
本质其实就是一个js对象，它可以包含我们组件中任意功能选项，如data、components、methods 、created、computed等等
我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来
在Vue中我们可以局部混入跟全局混入

同名的props、methods、inject、computed会被后来者代替

当目标 data 对象不包含当前属性时，调用 set 方法进行合并（set方法其实就是一些合并重新赋值的方法）
当目标 data 对象包含当前属性并且当前值为纯对象时，递归合并当前对象值，这样做是为了防止对象存在新增属性

生命周期钩子和watch被合并为一个数组，然后正序遍历一次执行

替换型策略有props、methods、inject、computed，就是将新的同名参数替代旧的参数
合并型策略是data, 通过set方法进行合并和重新赋值
队列型策略有生命周期函数和watch，原理是将函数存入一个数组，然后正序遍历依次执行
叠加型有component、directives、filters，通过原型链进行层层的叠加
### 改进
特别深入的东西，常用的优化手段（不是，整个页面块级的 我有一个很长的页面或者一个需要强制依赖第三方依赖的资源），页面有很多块
没有考虑到

页面有很多组件，组件又分为优先级，先可视区域和后可视区域的这些东西，这些优化手段
源码和原理
nginx反向代理
基础打牢，js继承不太熟练，js API全部过一遍，

vue底层，vue源码，养成好的编码习惯，
技术深度上提升，

深度和广度上提高一些，推动面试官去想触打的知识点