<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
       //  3.借用构造函数继承
      /*   重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））
　　　　优点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
　　　　　　　2、解决了原型链继承缺点1、2、3。
　　　　　　　3、可以继承多个构造函数属性（call多个）。
　　　　　　　4、在子实例中可向父实例传参。
            5、解决了原型链实现继承的不能传参的问题和父类的原型共享的问题。 
　　　　缺点：1、只能继承父类构造函数的属性。
　　　　　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）
　　　　　　　3、每个新实例都有父类构造函数的副本，臃肿。
            4、子类无法访问父类原型中的方法和属性。（这个原型链继承可以解决) */
      function Parent() {
        this.age = 22;
        this.hobbyList = ['唱歌']
      }
      Parent.prototype.sex = "男";

      function Child() {
        this.name = "张三";
        // 创建子类实例时调用Parent构造函数，于是Child的每个实例都会将Parent中的属性复制一份
        // this指向Child
        Parent.call(this);
      }
     //  无法继承父类原型的属性。
      let o1 = new Child(); 
      let o2 = new Child();

      console.log(o1);  // child {age: 22, name: "张三"} hobbyList: ['唱歌']
      console.log(o2);  // child {age: 22, name: "张三"} hobbyList: ['唱歌']
     
    </script>
  </body>
</html>
