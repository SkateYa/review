<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*  
            原理：以数组的第一个数据为基准，想象成一个只有一个数据的数组，将剩下的数据依次插入基准数据所在的数组中合适的位置。
        以 const arr = [5,2,1,3,6,8,4,5,7,0,15]; 为例。
        基准数据为下标是 0 的数据 5，将基准数据想象成一个数组即：[5] ，第一次遍历需要进行插入的数据时下标为 1 的数据 2，
        因为 2 < 5 ，所以将 2 插入到 5 之前，即：[2,5]。剩下的数据重复以上操作即可。
    */
      // 插入排序 1
      // 它的思想是将数组分为已排序和未排序两部分，初始时已排序部分只有一个元素，然后逐步将未排序部分中的元素
      // 插入到已排序部分的正确位置上。通过重复这个过程，最终使得整个数组有序
      const arr = [5, 2, 1, 3, 6, 8, 4, 5, 7, 0, 15];
      function pickFun(params) {
        let preIndex = 0; // 进行大小对比的基准数据的下标
        let current = 0; // 进行大小对比的当前选中的剩余数量值
        for (let i = 1; i < params.length; i++) {
          preIndex = i - 1; // 进行基准数据赋值
          current = params[i]; // 获取当前进行对比的剩余数量值
          while (preIndex >= 0 && params[preIndex] > current) {
            params[preIndex + 1] = params[preIndex];
            preIndex--;
          }
          params[preIndex + 1] = current;
        }
        return params;
      }
      const pickAns = pickFun(arr);
      console.log(pickAns, "----------------------插入排序");
      // [0, 1, 2, 3, 4, 5, 5, 6, 7, 8, 15] '----------------------插入排序'


      // 插入排序 2
      function insertionSort(arr) {
        const len = arr.length;
        for (let i = 1; i < len; i++) {
          let current = arr[i]; // 当前要插入的元素
          let j = i - 1; // 已排序部分的最后一个元素的索引（当前元素的上一个）
          // 如果上一个元素比当前元素大，就将上一个元素放到当前元素的位置（即后移）
          while (j >= 0 && arr[j] > current) {
            arr[j + 1] = arr[j];
            j--; // 继续往前比
          }
          // 将当前元素插入（赋值）到正确的位置（因为j--了，所以j + 1是正确位置）
          arr[j + 1] = current;
        }
        return arr;
      }
      console.log(insertionSort(arr)); // [0, 1, 2, 3, 4, 5, 5, 6, 7, 8, 15]
    </script>
  </body>
</html>
